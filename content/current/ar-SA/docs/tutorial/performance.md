# الأداء

كثيرا ما يسأل المطورون عن استراتيجيات تحسين أداء تطبيقات إلكترون. مهندسو البرمجيات، والمستهلكون، ومطوري الإطار لا يتفقون دائما على تعريف واحد لما يعنيه "الأداء". This document outlines some of the Electron maintainers' favorite ways to reduce the amount of memory, CPU, and disk resources being used while ensuring that your app is responsive to user input and completes operations as quickly as possible. علاوة على ذلك، نريد أن تحافظ جميع استراتيجيات الأداء على مستوى عالٍ لأمن تطبيقك.

الحكمة والمعلومات حول كيفية بناء مواقع ويب مع جافا سكريبت تنطبق بشكل عام على تطبيقات إلكترون أيضا. إلى حد ما، الموارد لمناقشة كيفية بناء العقدة المؤدية. تنطبق التطبيقات أيضًا، ولكن يجب توخي الحذر لفهم أن مصطلح "الأداء" يعني أشياء مختلفة لـ عقدة. s خلفية عن التطبيق الذي يعمل على العميل.

هذه القائمة مقدمة من أجل الراحة الخاصة بك - وهي تشبه إلى حد كبير قائمة التحقق من الأمان [](./security.md) - ليس المقصود بها أن تكون شاملة. ربما من الممكن إنشاء تطبيق إلكترون بطيء يتبع جميع الخطوات المبينة أدناه. إلكترون هو منصة تطوير قوية تمكنك، المطور، من القيام بأكثر من أو أقل مما تريد. كل هذه الحرية تعني أن الأداء هو إلى حد كبير مسؤوليتك.

## القياس والقياس والقياس

تحتوي القائمة أدناه على عدد من الخطوات المباشرة نوعا ما و سهلة التنفيذ. ومع ذلك، فإن بناء الإصدار الأكثر أداء من التطبيق الخاص بك سيتطلب منك الذهاب إلى ما هو أبعد من عدد من الخطوات. بدلاً من ذلك، سيتعين عليك فحص جميع التعليمات البرمجية التي تعمل في تطبيقك بعناية عن طريق تحديد الملف الشخصي و التقييم. أين هي الاختناقات؟ عندما ينقر المستخدم على زر، ما هو العمليات التي تستأثر بوطأة الوقت؟ في حين أن التطبيق عاطل ببساطة، أي الكائنات التي تستحوذ على معظم الذاكرة؟

مراراً وتكراراً، رأينا أن الاستراتيجية الأكثر نجاحاً لبناء تطبيق إلكترون مؤدي هو تحديد رمز التشغيل، ابحث عن أكثر قطعة من الموارد جوعا، ولتحسينها. تكرار هذه العملية الدؤوبة مراراً وتكراراً سيؤدي إلى زيادة كبيرة في أداء تطبيقك . الخبرة المكتسبة من العمل مع التطبيقات الرئيسية مثل Visual Studio Code أو Slack أظهرت أن هذه الممارسة هي إلى حد بعيد أكثر استراتيجية موثوقية من أجل تحسين الأداء.

لمعرفة المزيد حول كيفية وضع كود التطبيق الخاص بك، اطّلع على نفسك أدوات مطور كروم. للتحليل المتقدم الذي يبحث في عمليات متعددة في وقت واحد، فكر في [أداة تتبع كروم](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool).

### القراءة الموصى بها

 * [ابدأ مع تحليل أداء وقت التشغيل](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/)
 * [محادثة: "Visual Studio Code - The First Second"](https://www.youtube.com/watch?v=r0OeHRUCCb4)

## Checklist

الفرص هي أن التطبيق الخاص بك يمكن أن يكون أصغر قليلاً، أسرع، وأقل جوعًا بشكل عام إذا حاولت هذه الخطوات.

1. [تضمين وحدات بلا كلل](#1-carelessly-including-modules)
2. [تحميل وتشغيل التعليمات البرمجية في وقت مبكر جدا](#2-loading-and-running-code-too-soon)
3. [حظر العملية الرئيسية](#3-blocking-the-main-process)
4. [منع عملية العارض](#4-blocking-the-renderer-process)
5. [حشوات غير ضرورية](#5-unnecessary-polyfills)
6. [طلبات الشبكة غير ضرورية أو محظورة](#6-unnecessary-or-blocking-network-requests)
7. [قم بتجميع الكود الخاص بك](#7-bundle-your-code)

## 1) إدراج وحدات بلا كلل

قبل إضافة وحدة Node.js إلى التطبيق الخاص بك، افحص الوحدة المذكورة. كم عدد التبعيات التي تضمنتها هذه الوحدة؟ ما هو نوع الموارد التي تحتاج ببساطة إلى استدعائها في `اشتراط ()` بيان؟ قد تجد أن الوحدة مع معظم التنزيلات في سجل حزمة NPM أو أكثر النجوم في GitHub ليست في الواقع أصغر أو أصغر واحدة متاحة.

### لما؟

إن المنطق وراء هذه التوصية هو أفضل مثال على عالم واقعي . خلال الأيام الأولى من إلكترون، كان الكشف الموثوق به عن اتصال الشبكة مشكلة. نتجت عن العديد من التطبيقات استخدام وحدة كشفت طريقة بسيطة `isOnline()`.

اكتشفت هذه الوحدة الاتصال بالشبكة الخاصة بك عن طريق محاولة الوصول إلى عدد من النقاط الطرفية المعروفة. بالنسبة لقائمة هذه النقاط النهائية، فإنها تعتمد على وحدة مختلفة، والتي تحتوي أيضا على قائمة من الموانئ المعروفة. اعتمد هذا التبعية نفسه على وحدة تحتوي على معلومات عن الموانئ، الذي جاء في شكل ملف JSON مع أكثر من 100000 سطر من المحتوى. كلما تم تحميل الوحدة (عادة في بيان `المطلوب('وحدة')` )، ستقوم بتحميل جميع التبعيات وفي نهاية المطاف قراءة وتحليل ملف JSON هذا. إن تحليل عدة آلاف من خطوط JSON عملية باهظة التكلفة. على آلة بطيئة يمكن أن تستغرق ثوانًا كاملة من الوقت.

في العديد من سياقات الخوادم، يكون وقت بدء التشغيل غير ذي صلة تقريبا. عقدة s خادم الذي يتطلب معلومات حول جميع المنافذ من المحتمل أن يكون في الواقع "أكثر أداءً" إذا قام بتحميل جميع المعلومات المطلوبة في الذاكرة كلما قام الخادم بتشغيل فائدة تقديم الطلبات بشكل أسرع. الوحدة التي نوقشت في هذا المثال هي ليست وحدة "سيئة". ومع ذلك، لا ينبغي أن تكون تطبيقات إلكترون تحميل، تحليل، و تخزين في معلومات الذاكرة التي لا تحتاج إليها في الواقع.

باختصار، قد تكون وحدة كتبت بشكل أساسي لـ Node.js خوادم تشغيل Linux أخبار سيئة لأداء تطبيقك. في هذا المثال على وجه الخصوص، كان الحل الصحيح هو عدم استخدام وحدة على الإطلاق. واستخدم بدلاً من ذلك فحوصات الاتصال المضمنة في الإصدارات الأخيرة من Chromium.

### كيف؟

عند النظر في وحدة نموذجية، ننصحك بالتحقق من:

1. حجم الإعتمادات يشمل 2) الموارد المطلوبة لتحميل (`يتطلب ()`)
3. الموارد المطلوبة لتنفيذ الإجراء الذي تهتم به

يمكن إنشاء ملف تعريف لوحدة المعالجة المركزية وملف تعريف الذاكرة الرقيقة لتحميل الوحدة النمطية باستخدام أمر واحد على سطر الأوامر. في المثال أدناه، نحن ننظر إلى الوحدة الشعبية `طلب`.

```sh
العقدة --cpu-prof --heap-prof -e "مطلوب" ('request')"
```

تنفيذ هذا الأمر ينتج في ملف `.cpuprofile` و `ملف .heappro` في الدليل الذي نفذته فيه. يمكن تحليل كلا الملفين باستخدام أدوات مطوري كروم، باستخدام `الأداء` و `علامات تبويب الذاكرة` على التوالي.

![Performance-cpu-prof](../images/performance-cpu-prof.png)

![الأداء - الطاعة](../images/performance-heap-prof.png)

في هذا المثال ، على آلة المؤلف ، رأينا أن طلب التحميل `` أخذ نصف ثانية تقريبا، بينما `إحضار العقدة` أخذ ذاكرة أقل بشكل كبير وأقل من خمسين مليمتر.

## 2) تحميل وتشغيل التعليمات البرمجية في وقت مبكر جداً

إذا كان لديك عمليات إعداد باهظة الثمن، فكر في تأجيل هذه العمليات. افحص كل العمل الذي يتم تنفيذه مباشرة بعد بدء الطلب. بدلاً من إطلاق من جميع العمليات على الفور، فكر في تتابعها بشكل أكثر تتواءم بشكل وثيق مع رحلة المستخدم.

في التطوير التقليدي لـ Node.js ، نحن نستخدم لوضع كل بياناتنا `المطلوبة ()` في الأعلى. إذا كنت تكتب حاليا تطبيق إلكترون باستخدام نفس الاستراتيجية _و_ تستخدم وحدات كبيرة لا تحتاج إليها على الفور، تطبيق نفس الاستراتيجية وتأجيل التحميل إلى وقت أكثر مناسب.

### لما؟

تحميل الوحدات هو عملية باهظة التكلفة بشكل مفاجئ، خاصة على Windows. عند بدء تشغيل التطبيق الخاص بك، لا ينبغي أن يجعل المستخدمين ينتظرون العمليات التي ليست ضرورية حاليا.

قد يبدو هذا واضحاً، لكن العديد من التطبيقات تميل إلى القيام بقدر كبير من العمل مباشرة بعد بدء تشغيل التطبيق - مثل التحقق من وجود تحديثات، تحميل المحتوى المستخدم في تدفق لاحق، أو أداء عمليات القرص الثقيل I/O

دعونا نعتبر برنامج Visual Studio كمثال. عند فتح ملف، سيقوم بعرض الملف لك على الفور دون تسليط الضوء على أي تعليمة برمجية، إعطاء الأولوية لقدرتك على التفاعل مع النص. بمجرد أن تنجز ذلك العمل، ستنتقل إلى تسليط الضوء على البرمجة.

### كيف؟

دعونا ننظر في مثال وافترضنا أن التطبيق الخاص بك يقوم بتحليل الملفات بصيغة افتراضية `.foo`. من أجل القيام بذلك، يعتمد على وحدة التي تساوى في الوهمية `foo-parser`. في التطوير التقليدي Node.js، قد تكتب التعليمات البرمجية التي تحمّل التبعية بشكل:

```js
const fs = مطلوب('fs')
const fooParser = مطلوب('foo-parser')

class Parser {
  cretor () {
    هذا. ملفات = fs.readdirSync('. )
  }

  getParsedFile () {
    RefooParser.parse(هذا). iles)
  }
}

Const parser = Parser() جديدة()

module.exports = { parser }
```

في المثال أعلاه نقوم بالكثير من العمل الذي يتم تنفيذه بمجرد عندما يتم تحميل الملف. هل نحن بحاجة إلى الحصول على الملفات المنبوذة على الفور؟ هل يمكننا القيام بهذا العمل بعد قليل، عندما يسمى `getParsedFiles()` فعليًا؟

```js
// "الذوبان على الأرجح قيد التحميل مسبقاً, لذا فإن المكالمة 'require()' رخيصة
const fs = require('fs')

class Parser {
  async getFiles () {
    // Touch على القرص بمجرد أن يتم استدعاء 'getFiles' ليس أقرب.
    // أيضًا ، تأكد من أننا لا نمنع العمليات الأخرى باستخدام
    // الإصدار المتزامن.
    هذه الملفات = this.files <unk> <unk> <unk> انتظر fs.readdir('.')

    إرجاع هذا. ملفات
  }

  async getParsedFile () {
    // / نظامنا الوهمي foo-parser هو وحدة كبيرة ومكلفة للتحميل، لذلك
    / إرجاء ذلك العمل إلى أن نحتاج في الواقع إلى تحليل الملفات.
    // بما أن 'require()' يأتي مع ذاكرة التخزين المؤقت للوحدة، مكالمة 'require()'
    // ستكون مكلفة مرة واحدة فقط - المكالمات اللاحقة من 'getParsedFiles()'
    // ستكون أسرع.
    const fooParser = مطلوب('foo-parser')
    ملفات const = انتظار هذا.getFiles()

    RefooParser. arse(files)

}

// هذه العملية هي الآن أرخص بكثير من مثالنا السابق
const parser = Parser() جديد

. xports = { parser }
```

باختصار، تخصيص الموارد "فقط في الوقت المناسب" بدلاً من تخصيصها كلها عند بدء تشغيل التطبيق.

## 3 - منع العملية الرئيسية

العملية الرئيسية للـ Electron's (تسمى أحياناً "عملية المتصفح") هي خاصة: هي العملية الأصلية لجميع العمليات الأخرى لتطبيقك والعملية الأساسية يتفاعل نظام التشغيل معها. يتعامل مع النوافذ والتفاعلات و التواصل بين مختلف المكونات داخل التطبيق الخاص بك. كما أنه يضم موضوع واجهة المستخدم.

لا ينبغي تحت أي ظرف من الظروف حظر هذه العملية وخط واجهة المستخدم مع عمليات طويلة الأمد. حظر موضوع واجهة المستخدم يعني أن تطبيقك بأكمله سيجمد حتى تكون العملية الرئيسية جاهزة لمواصلة المعالجة.

### لما؟

العملية الرئيسية و موضوع واجهة المستخدم هي أساسا برج المراقبة للعمليات الرئيسية داخل التطبيق الخاص بك. عندما يخبر نظام التشغيل تطبيقك عن نقرة على الماوس، فإنه سيمر عبر العملية الرئيسية قبل أن يصل إلى نافذتك. إذا كانت نافذتك تقوم بعمل رسوم متحركة سلسة لليانصيب، سوف تحتاج إلى التحدث إلى عملية الوحدة العامة حول ذلك - مرة أخرى تمر عبر العملية الرئيسية.

إلكترون وكروميوم حريصان على وضع عمليات القرص الثقيل I/O و المعالجة المركزية على مواضيع جديدة لتجنب حظر موضوع واجهة المستخدم. عليك أن تفعل الشيء نفسه.

### كيف؟

بنية شركة Electron's القوية متعددة العمليات على استعداد لمساعدتك في مهامك التي تعمل منذ وقت طويل، ولكنها تتضمن أيضا عددا صغيرا من فخاخ الأداء.

1) للمهام الثقيلة التي يعمل بها المعالج، استخدم [مواضيع العامل](https://nodejs.org/api/worker_threads.html)، التفكير في نقلهم إلى نافذة المتصفح، أو (كحل أخير) تولد عملية مكرسة.

2) تجنب استخدام وحدة IPC المتزامنة و `عن بعد` قدر الإمكان. على الرغم من وجود حالات استخدام مشروعة، فإنه من السهل جداً حظر موضوع واجهة المستخدم دون معرفة باستخدام `الوحدة النمطية` البعيدة.

3 - تجنب استخدام وقف عمليات المنظمات الدولية في العملية الرئيسية. باختصار، كلما عقدة أساسية. s وحدات (مثل `fs` أو `child_process`) تقدم نسخة متزامنة أو غير متزامنة، يجب عليك أن تفضل المتغير غير المتزامن وغير المحظور .


## 4) منع عملية العارض

منذ سفن إلكترون مع النسخة الحالية من كروم، يمكنك استخدام أحدث وأهم الميزات التي تعرضها منصة الويب لتأجيل أو تفريغ العمليات الثقيلة بطريقة تحافظ على سلاسة التطبيق واستجابته.

### لما؟

ربما يحتوي تطبيقك على الكثير من جافا سكريبت لتشغيله في عملية المعرض. الخدعة هي تنفيذ العمليات بأسرع ما يمكن دون أخذ الموارد اللازمة لمواصلة التمرير بسلاسة، الرد على مدخلات المستخدم، أو الرسوم المتحركة عند 60fps.

تنظيم تدفق العمليات في كود العارض الخاص بك هو مفيد بشكل خاص إذا اشتكى المستخدمون من التطبيق الخاص بك في بعض الأحيان "التعزيز".

### كيف؟

بشكل عام، جميع النصائح لبناء تطبيقات ويب مؤدية لمتصفحات الحديثة تنطبق على عارضي Electron، أيضًا. الأداتان الرئيسيتان تحت تصرفك هما حاليا `requestIdleCallback()` للعمليات الصغيرة و `عمال الشبكة` للعمليات الطويلة الأجل.

*`requestIdleCallback()`* يسمح للمطورين بالانتظار إلى وظيفة لكي يتم تنفيذها بمجرد دخول العملية إلى فترة الخمول. يمكنك من القيام بعمل منخفض الأولوية أو الخلفية دون التأثير على تجربة المستخدم. لمزيد من المعلومات حول كيفية استخدامه، [تحقق من وثائقه على MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback).

*عمال الويب* أداة قوية لتشغيل التعليمات البرمجية على موضوع منفصل. هناك بعض المحاذير التي يجب أخذها بعين الاعتبار - راجع وثائق Electron's [متعددة المواضيع](./multithreading.md) و [وثائق MDN لعمال الشبكة](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). إنها حل مثالي لأي عملية تتطلب الكثير من الطاقة لوحدة المعالجة المركزية لفترة طويلة من الوقت.


## 5 - البوليمترات غير الضرورية

أحد الفوائد العظيمة لشركة Electron's هو أنك تعرف بالضبط أي المحرك سي تحليل جافا سكريبت و HTML و CSS. إذا كنت تعيد تحديد الغرض من التعليمات البرمجية التي تم كتابتها للويب ككل، تأكد من عدم وجود ميزات متعددة الملء في إلكترون.

### لما؟

عند بناء تطبيق ويب لإنترنت اليوم، تملي أقدم البيئات الميزات التي يمكنك أو لا يمكنك استخدامها. على الرغم من أن إلكترون يدعم فلاتر CSS الجيدة الأداء والرسوم المتحركة، قد لا يدعم المتصفح القديم. حيث يمكنك استخدام WebGL، قد يكون المطورين اختروا حلاً أكثر جوعًا من الموارد لدعم الهواتف القديمة.

عندما يتعلق الأمر بجافا سكريبت، ربما قمت بتضمين مكتبات أدوات مثل jQuery لمحددات DOM أو البوليفائيات مثل `إعادة التشغيل` لدعم `async/انتظار`.

من النادر أن يكون البولي بوليملئ جافا سكريبت أسرع من الميزة الأصلية المكافئة في إلكترون. لا تبطئ تطبيق إلكترون بشحن الخاص بك من الميزات القياسية لمنصة الويب.

### كيف؟

قم بالعمل على افتراض أن البوليفترات في الإصدارات الحالية من إلكترون غير ضرورية. إذا كان لديك شكوك ، تحقق من [om](https://caniuse.com/) وتحقق مما إذا كان إصدار [من Chromium المستخدم في إصدار Electron الخاص بك](../api/process.md#processversionschrome-readonly) يدعم الميزة التي تريدها.

بالإضافة إلى ذلك، ابحث بعناية في المكتبات العامة التي تستخدمها. هل هي ضرورية حقاً؟ `jQuery`، على سبيل المثال ، كان نجاحاً لدرجة أن العديد من ميزاته أصبحت الآن جزءاً من [مجموعة ميزات جافا سكريبت القياسية المتاحة](http://youmightnotneedjquery.com/).

إذا كنت تستخدم جهاز نقل/تجميع مثل TypeScript، فحصوا إعداداته وتأكدوا من أنك تستهدف أحدث إصدار ECMAScript المدعوم من قبل إلكترون.


## 6 - طلبات الشبكة غير الضرورية أو المحظورة

تجنب جلب الموارد النادرة من الإنترنت إذا كان من الممكن بسهولة تجميعها مع تطبيقك.

### لما؟

يبدأ العديد من مستخدمي إلكترون بتطبيق يعتمد كلياً على شبكة الإنترنت بتحويلهم إلى تطبيق سطح المكتب. باعتبارنا مطوري الويب، نحن نستخدم لتحميل موارد من مجموعة متنوعة من شبكات توصيل المحتوى. الآن بعد أن كنت شحن تطبيق سطح المكتب الصحيح، حاول "قطع cord" حيثما كان ذلك ممكناً وتجنب السماح للمستخدمين بالانتظار للحصول على موارد لا تتغير أبداً و يمكن إدراجها بسهولة في التطبيق الخاص بك.

مثال نموذجي هو خطوط جوجل. العديد من المطورين يستخدمون مجموعة جوجل الرائعة من الخطوط المجانية، والتي تأتي مع شبكة تسليم المحتوى . هذه اللوحة واضحة: تشمل بعض الأسطر من CSS و Google ستعالج البقية.

عند إنشاء تطبيق إلكترون ، يتم خدمة المستخدمين بشكل أفضل إذا قمت بتنزيل الخطوط وإدراجها في حزمة التطبيق الخاصة بك.

### كيف؟

في عالم مثالي، لن يحتاج تطبيقك إلى الشبكة لتعمل على كل شيء. للوصول إلى هناك، يجب أن تفهم الموارد التي يقوم تطبيقك بتنزيل \-، ومدى حجم هذه الموارد.

للقيام بذلك، افتح أدوات المطور. انتقل إلى `الشبكة` علامة التبويب و تحقق من `تعطيل ذاكرة التخزين المؤقت`. ثم قم بإعادة تحميل عرضك. ما لم يحظر تطبيقك إعادة التحميل هذه، يمكنك عادة تشغيل إعادة تحميل بضرب `Cmd + R` أو `Ctrl + R` مع أدوات المطور في التركيز.

ستسجل الأدوات الآن بدقة جميع طلبات الشبكة. في أول تمرير، قم بتقييم جميع الموارد التي يتم تحميلها، مع التركيز على الملفات الأكبر أولا. هل يمكن إدراج أي من هذه الصور أو الخطوط أو ملفات الوسائط التي لا تتغير و مع حزمتك؟ وإذا كان الأمر كذلك، فإنها تشملها.

كخطوة تالية، قم بتفعيل `خنق الشبكة`. ابحث عن القائمة المنسدلة التي حاليا يقرأ `على الإنترنت` وحدد سرعة أبطأ مثل `سرعة 3G سريعة`. قم بإعادة تحميل المعرض الخاص بك وشاهد ما إذا كان هناك أي موارد يكون تطبيقك غير ضروري في انتظاره. في العديد من الحالات، سينتظر التطبيق طلب الشبكة لإكمال على الرغم من عدم الحاجة إلى المورد المعني.

كنصيحة ، فإن تحميل الموارد من الإنترنت التي قد ترغب في تغييرها دون شحن تحديث التطبيق هو استراتيجية قوية. من أجل التحكم المتقدم في كيفية تحميل الموارد، فكر في الاستثمار في [عمال الخدمة](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API).

## 7) حزم التعليمات البرمجية الخاصة بك

كما سبقت الإشارة إليه في "[تحميل الكود وتشغيله في وقت مبكر جداً](#2-loading-and-running-code-too-soon)"، استدعاء `المتطلبات()` عملية مكلفة. إذا كنت قادراً على القيام بذلك، قم بتجميع كود التطبيق الخاص بك في ملف واحد.

### لما؟

عادة ما يتضمن تطوير جافا سكريبت عصري العديد من الملفات والوحدات. بينما هذا جيد تماما للتطوير مع إلكترون، نوصي بشدة بأن تقوم بتجميع جميع التعليمات البرمجية الخاصة بك في ملف واحد لضمان أن النفقات العامة المدرجة في المكالمة `تتطلب ()` فقط مرة واحدة عندما يحمّل تطبيقك.

### كيف؟

هناك العديد من مجموعات جافا سكريبت هناك ونحن نعرف أفضل من غضب المجتمع من خلال التوصية بأداة على أداة أخرى. ومع ذلك، نحن نوصي بأن تستخدم حزمة قادرة على التعامل مع بيئة إلكترون الفريدة التي تحتاج إلى التعامل مع كلا العقدتين. s وبيئات المتصفح.

حتى كتابة هذه المقالة، تشمل الخيارات الشائعة [Webpack](https://webpack.js.org/)، [Parcel](https://parceljs.org/)، و [rollup.js](https://rollupjs.org/).
