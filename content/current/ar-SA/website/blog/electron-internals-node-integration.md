---
title: 'كترون داخلي&#58؛ تكامل حلقة الرسائل'
author: zcbenz
date: '2016-07-28'
---

هذه هي الوظيفة الأولى في سلسلة تشرح الداخليين لشركة إلكترون الإلكترونية. يقدم هذا المنشور كيفية دمج حلقة حدث العقد مع Chromium في Electron.

---

وقد جرت محاولات عديدة لاستخدام العقدة في برمجة واجهة المستخدم (GGI)، مثل [عقدة](https://github.com/zcbenz/node-gui) لربط GTK+، و [عقدة qt](https://github.com/arturadib/node-qt) لربط QT. لكن لا أحد منها يعمل في الإنتاج لأن مجموعات أدوات واجهة المستخدم GI لديها حلقات رسالتها الخاصة بينما العقدة تستخدم ليبوف لحلقة الحدث الخاصة بها، ويمكن للموضوع الرئيسي فقط تشغيل حلقة واحدة في نفس الوقت. لذا فالحيلة الشائعة لتشغيل حلقة رسالة واجهة المستخدم في عقدة هي ضخ حلقة الرسالة في مؤقت بفاصل صغير جداً, والذي يجعل استجابة واجهة الواجهة بطيئة ويشغل الكثير من موارد المعالج.

خلال تطوير إلكترون واجهنا نفس المشكلة، على الرغم من ذلك بطريقة معكوسة : كان علينا دمج حلقة حدث العقد في حلقة رسالة Chromium .

## العملية الرئيسية وعملية العارض

قبل أن نغوص في تفاصيل تكامل حلقة الرسائل، سأشرح أولاً هندسة تعدد العمليات في كروميوم.

في إلكترون هناك نوعان من العمليات: العملية الرئيسية و عملية المعرض (هذا في الواقع مبسط للغاية, للحصول على عرض كامل، يرجى الاطلاع على [المعماري المتعدد العمليات](http://dev.chromium.org/developers/design-documents/multi-process-architecture)). العملية الرئيسية مسؤولة عن عمل واجهة المستخدم مثل إنشاء النوافذ، في حين أن عملية العرض تتعامل فقط مع تشغيل وعرض صفحات الويب.

يسمح إلكترون باستخدام جافا سكريبت للتحكم في كل من العملية الرئيسية و عملية المعرض مما يعني أننا يجب أن ندمج العقدة في كلتا العمليتين.

## استبدال حلقة رسالة Chromium's بـ libuv

كانت محاولتي الأولى إعادة تنفيذ حلقة رسائل Chromium's باستخدام libuv.

كان من السهل بالنسبة لعملية العرض، لأن حلقة الرسائل الخاصة بها لم تستمع إلا إلى أوصاف الملفات والمؤقتين، وكنت بحاجة فقط إلى تنفيذ الواجهة مع libuv.

غير أن هذه العملية كانت أصعب بكثير بالنسبة للعملية الرئيسية. كل منصة لديها نوعها الخاص من حلقات رسائل واجهة المستخدم الخاصة بها. يستخدم MacOS Chromium `NSRunLoop`، بينما يستخدم Linux glib. حاولت الكثير من الاختراقات لاستخراج أوصاف الملفات الأساسية من حلقات رسائل واجهة المستخدم المحلية، ثم طعامهم ليحشوا للتكرار، لكنني لا زلت قابلت حالات حادة لم تنجح.

في النهاية قمت بإضافة مؤقت لاستطلاع حلقة رسالة الواجهة الواجهة الواجهة الواجهة الواجهة في فترة صغيرة. نتيجة لذلك، أخذت العملية استخدام وحدة المعالجة المركزية المستمر، وبعض العمليات كان لها تأخيرات طويلة.

## حلقة حدث عقدة الاقتراع في موضوع منفصل

ومع نضج الدهشة أصبح من الممكن حينئذ اتباع نهج آخر.

تم إدخال مفهوم fd الخلفية في ليبوف، وهو وصف الملفات (أو هدي) الذي يقوم باستطلاعات الليبوف لحلقة الحدث الخاصة به. إذاً من خلال التصويت على Fd الخلفية ، يمكن الحصول على إشعار عندما يكون هناك حدث جديد في libuv.

لذا في إلكترون قمت بإنشاء موضوع منفصل لاستطلاع الطعام، وبما أنني كنت أستخدم مكالمات النظام لإجراء التصويت بدلا من الـ libuv API، فقد كان الموضوع آمن. وكلما كان هناك حدث جديد في حلقة حدث ليبوف، ستنشر رسالة في حلقة رسالة كروموم، وستتم بعد ذلك معالجة أحداث الليبوف في الموضوع الرئيسي.

بهذه الطريقة تجنبت تصحيح الكروم والعقد، وقد استخدمت نفس الكود في العمليات الرئيسية وعمليات العرض.

## الكود البرمجي

يمكنك العثور على تنفيذ تكامل حلقة الرسائل في `node_bindings` ملفات تحت [`electron/atom/common`](https://github.com/electron/electron/tree/master/atom/common). يمكن أن يكون إعادة استخدامه بسهولة للمشاريع التي تريد دمج العقدة.

