---
title: 'إلكترون الداخلي&#58؛ مراجع ضعيفة'
author: zcbenz
date: '2016-09-20'
---

لغة مع جمع القمامة، جافا سكريبت يحرر المستخدمين من إدارة الموارد يدويا. لكن لأن إلكترون يستضيف هذه البيئة، يجب أن يكون حذرا جدا لتجنب كل من الذاكرة وتسرب الموارد.

يقدم هذا المنشور مفهوم المراجع الضعيفة وكيفية استخدامها لإدارة الموارد في إلكترون.

---

## مراجع ضعيفة

في جافا سكريبت، عندما تقوم بتعيين كائن إلى متغير، فإنك تضيف إشارة إلى الكائن. As long as there is a reference to the object, it will always be kept in memory. بمجرد انتهاء جميع الإشارات إلى الكائن، أي هناك لم تعد متغيرات تخزن الكائن، محرك جافا سكريبت سوف يستعيد الذاكرة على مجموعة القمامة التالية.

إشارة ضعيفة هي إشارة إلى كائن يسمح لك بالحصول على الكائن دون التأثير على ما إذا كان سيتم جمع القمامة أم لا. سوف تحصل أيضًا على إشعار عندما يتم جمع القمامة. ثم يصبح من الممكن إدارة الموارد باستخدام جافا سكريبت.

استخدام صف `NativeImage` في إلكترون كمثال، في كل مرة تدعى فيها `الصورة الأم. reate()` API ، سيتم إرجاع مثيل `صورة محلية` وهو يخزن بيانات الصورة في C+++. بمجرد الانتهاء منك باستخدام المثيل و محرك جافا سكريبت (V8) قد جمع الكائن، التعليمات البرمجية في C++ ستكون مطلوبة لتحرير بيانات الصورة في الذاكرة، لذلك لا حاجة إلى إدارة المستخدمين هذا يدويا.

مثال آخر هو [مشكلة اختفاء النافذة](https://electronjs.org/docs/faq/#my-apps-windowtray-disappeared-after-a-few-minutes)، أي يظهر بصرياً كيف يتم جمع النافذة عندما تنتهي جميع الإشارات إليها .

## اختبار المراجع الضعيفة في إلكترون

لا توجد طريقة للاختبار المباشر للمراجع الضعيفة في JavaScript لأن اللغة ليست لديها طريقة لتعيين مراجع ضعيفة. API الوحيد في جافا سكريبت المرتبط بضعف المراجع هو [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap)، ولكن بما أنه فقط ينشئ مفاتيح مرجعية ضعيفة، فمن المستحيل معرفة متى تم جمع قمامة.

في إصدارات إلكترون قبل v0.37.8، يمكنك استخدام الإصدار الداخلي `v8Util. تلميد` API لاختبار المراجع الضعيفة، الذي يضيف إشارة ضعيفة إلى الكائن الذي يمر ويتصل برد الاتصال عندما يتم جمع الكائن من القمامة:

```javascript
// الرمز أدناه يمكن أن يعمل فقط على إلكترون < v0.37.8.
var v8Util = process.atomBinding('v8_util')

var object = {}
v8Util. etDestructor(object, function () {
  console.log('الكائن هو جمع القمامة')
})

// إزالة جميع المراجع إلى الكائن.
الكائن = غير معرف
// يبدأ يدوياً GC.
gc()
// وحدة الطباعة "الكائن الذي تم جمعه من القمامة".
```

لاحظ أنه يجب عليك بدء تشغيل إلكترون باستخدام `--js-flags="--expose_gc"` أمر تبديل لفضح الدالة الداخلية `gc`.

تمت إزالة API في إصدارات لاحقة لأن V8 في الواقع لا يسمح بتشغيل كود جافا سكريبت في المدمر وفي الإصدارات اللاحقة سيسبب أعطال عشوائية.

## مراجع ضعيفة في وحدة `عن بعد`

بالإضافة إلى إدارة الموارد الأصلية باستخدام C++، يحتاج إلكترون أيضًا إلى مراجع ضعيفة لإدارة موارد جافا سكريبت. مثال على ذلك وحدة Electron's `البعيد` ، والذي هو [مكالمة إجرائية عن بعد](https://en.wikipedia.org/wiki/Remote_procedure_call) (RPC) التي تسمح باستخدام الكائنات في العملية الرئيسية من عمليات العرض.

أحد التحديات الرئيسية مع وحدة `البعيد` هو تجنب تسرب الذاكرة. عندما يحصل المستخدمون على كائن بعيد في عملية العرض، يجب أن تضمن وحدة `البعيد` استمرار الكائن في العملية الرئيسية حتى تنتهي المراجع في عملية المعرض. وبالإضافة إلى ذلك، كما يجب أن يتأكد من أن الكائن يمكن أن يتم جمعه عندما لا يكون هناك أي إشارة إليه في عمليات العرض.

على سبيل المثال، بدون التنفيذ السليم، سيتسبب التتبع في تسرب الذاكرة بسرعة:

```javascript
const {remote} = require('electron')

لـ (let i = 0; i < 10000; ++i) {
  remote.nativeImage.createEmpty()
}
```

إدارة الموارد في وحدة `البعيد` بسيطة. كلما طلب كائن ، يتم إرسال رسالة إلى العملية الرئيسية وسيقوم إلكترون بتخزين الكائن في خريطة وتعيين معرف له، ثم ارسل المعرف مرة أخرى إلى عملية العرض. في عملية العرض، وحدة `البعيد` سوف تتلقى المعرف و تلقيه مع كائن الوكيل و عندما يكون الكائن الوكيل هو القمامة ، سيتم إرسال رسالة إلى العملية الرئيسية لتحرير الكائن.

باستخدام `Remote.require` API كمثال، يبدو التطبيق المبسط مثل هذا:

```javascript
remote.require= وظيفة (name) {
  // أخبر العملية الرئيسية لإرجاع البيانات الوصفية للوحدة.
  const meta = ipcRenderer.sendSync('REQUIRE', name)
  // إنشاء كائن بروكسي.
  الكائن = metaToValue(meta)
  // أخبر العملية الرئيسية لتحرير الكائن عندما يكون الكائن الوكيل هو القمامة
  // تم جمعها.
  v8Util.setDestructor(object, function () {
    ipcRenderer.send('FREE', meta.id)
  })
  عنصر الإرجاع
}
```

In the main process:

```javascript
const map = {}
const id = 0

ipcMain. n('REQUIRE', دالة (الحدث، الاسم) {
  كائن الفتحة = مطلوبة (الاسم)
  // إضافة إشارة إلى الكائن.
  خريطة [++id] = كائن
  // تحويل الكائن إلى بيانات التعريف
  event.returValue = valueToMeta(id, object)
})

ipcMain.on('FREE', function (event, id) {
  حذف الخريطة[id]
})
```

## خرائط ذات قيم ضعيفة

مع التنفيذ البسيط السابق، كل مكالمة في وحدة `البعيد` ست إرجاع كائن بعيد جديد من العملية الرئيسية. وكل كائن بعيد يمثل إشارة إلى الكائن في العملية الرئيسية.

التصميم نفسه جيد، ولكن المشكلة هي عندما تكون هناك مكالمات متعددة للحصول على نفس الكائن، سيتم إنشاء أشياء متعددة الوكيل ول أشياء معقدة يمكن أن يضيف هذا ضغطاً هائلاً على استخدام الذاكرة والقمامة مجموعة.

على سبيل المثال، الرمز التالي:

```javascript
const {remote} = require('electron')

لـ (let i = 0; i < 10000; ++i) {
  remote.getcurrentWindow()
}
```

تستخدم أولاً الكثير من الذاكرة لإنشاء كائنات وكيلة ثم تشغل وحدة المعالجة المركزية (وحدة المعالجة المركزية) من أجل جمع القمامة وإرسال رسائل IPC .

تحسين واضح هو تخزين الكائنات البعيدة: عندما يكون هناك بالفعل كائن بعيد بنفس المعرف، سيتم إرجاع الكائن البعيد السابق بدلاً من إنشاء كائن جديد.

هذا غير ممكن مع API في جوهر جافا سكريبت. استخدام الخريطة العادية للتخزين المؤقت للأشياء سيمنع V8 من القمامة التي تجمع الأشياء، في حين أن فئة [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) يمكن فقط استخدام الكائنات كمفاتيح ضعيفة.

لحل هذه المشكلة، يتم إضافة نوع خريطة مع قيم كمراجع ضعيفة، وهو مثالي للتخزين المؤقت للأشياء مع المعرفات. الآن `البعيد مطلوب` يبدو مثل هذا:

```javascript
const remoteObjectCache = v8Util.createIDWeakMap()

remote.requirement = function (name) {
  // أخبر العملية الرئيسية لإرجاع بيانات التعريف من الوحدة.
  ...
  if (remoteObjectCache.has(meta.id))
    return remoteObjectCache.get(meta.id)
  // Create a proxy object.
  ...
  remoteObjectCache.set(meta.id, object)
  return object
}
```

لاحظ أن `RemoteObjectCache` يخزن الكائنات كمراجع ضعيفة، لذلك لا تحتاج إلى حذف المفتاح عندما يتم جمع القمامة.

## الرمز الأصلي

للأشخاص المهتمين في كود C++ للمراجع الضعيفة في إلكترون، يمكن العثور على في الملفات التالية:

API `setDestructor`:

* [`object_life_monitor.cc`](https://github.com/electron/electron/blob/v1.3.4/atom/common/api/object_life_monitor.cc)
* [`object_life_monitor.ساعة`](https://github.com/electron/electron/blob/v1.3.4/atom/common/api/object_life_monitor.h)

API `إنشاء IDWeakMap`:

* [`الخريطة_المفتاح_الضعف.ساعة`](https://github.com/electron/electron/blob/v1.3.4/atom/common/key_weak_map.h)
* [`الذرة_api_key_weak_map.ساعة`](https://github.com/electron/electron/blob/v1.3.4/atom/common/api/atom_api_key_weak_map.h)

