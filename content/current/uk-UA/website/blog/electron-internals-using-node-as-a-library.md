---
title: 'Інтернали Electron&#58; використання вузла в якості бібліотеки'
author: zcbenz
date: '2016-08-08'
---

Це другий пост у триваючій серії з поясненням інтерналів Electron. Спробуйте [перше повідомлення](https://electronjs.org/blog/2016/07/28/electron-internals-node-integration) про інтеграцію циклу подій , якщо ви ще цього не зробили.

Більшість людей використовують [Node](https://nodejs.org) для застосунків на стороні сервера, але через багатого вузла API набір і процвітаючу спільноту, він також чудово підходить для вбудованої бібліотеки. Цей пост пояснює, як Node використовується в якості бібліотеки Electron.

---

## Збірка

І вузол, і Electron використовують [`GYP`](https://gyp.gsrc.io) під час своїх будівельних систем. Якщо ви хочете вставити Node у ваш додаток, ви повинні використовувати його також як свою будівельну систему.

Новий `GYP`? Прочитайте [це керівництво](https://gyp.gsrc.io/docs/UserDocumentation.md) перед продовженням в цьому повідомленні.

## Позначки вузла

Вузол [`. yp`](https://github.com/nodejs/node/blob/v6.3.1/node.gyp) файл з вихідним кодом вузла описує як Node , разом з великою кількістю [`GYP`](https://gyp.gsrc.io) змінні, які контролюють, які частини Node, а також відкриті певні конфігурації.

To change the build flags, you need to set the variables in the `.gypi` file of your project. Скрипт `налаштування` в Node може згенерувати деякі загальні конфігурації для вас, наприклад запущений `. налаштувати --shared` згенерує на `config.gypi` з змінними інструкцією Node для будівництва в якості спільної бібліотеки.

Electron не використовує `налаштований` скрипт, оскільки у нього є власні складські скрипти. Конфігурації для Node визначені в [`звичайній.gypi`](https://github.com/electron/electron/blob/master/common.gypi) файл в папці кореневого коду Electron.

## Посилання вузла з Electron

In Electron, Node is being linked as a shared library by setting the `GYP` variable `node_shared` to `true`, so Node's build type will be changed from `executable` to `shared_library`, and the source code containing the Node's `main` entry point will not be compiled.

Since Electron uses the V8 library shipped with Chromium, the V8 library included in Node's source code is not used. Це зроблено шляхом встановлення обох `node_use_v8_platform` і `node_use_bundled_v8` до `false`.

## Бібліотека кубиків або статична бібліотека

Під час зв'язку з вузлом існують два варіанти: ви можете побудувати вузол як статичну бібліотеку і включити її в останню чергу, або ви можете створити її у вигляді , спільної бібліотеки та поставлення її поруч з кінцевим виконанням.

В Electron Node був побудований як статична бібліотека тривалий час. Це зробило простий інструмент, увімкнув найкращу оптимізацію компілятора, і дозволили Electron розподіляти без додаткового `файлу node.dll`.

Тим не менш, це змінилося після переходу на Chrome використовувати [BoringSSL](https://boringssl.googlesource.com/boringssl). BoringSSL це форк [OpenSSL](https://www.openssl.org) , який видаляє декілька невикористаних API і змінює багато існуючих інтерфейсів. Оскільки вузол все ще використовує OpenSSL, компілятор створить численні посилання на помилки через конфліктуючі символи, якщо вони з'єднані разом.

Electron не зміг використовувати BoringSSL в Node, або використовувати OpenSSL в Chromium, таким чином єдиний параметр повинен був перемкнутися до будівлі Node як спільна бібліотека, і [приховати BoringSSL і OpenSSL символи](https://github.com/electron/electron/blob/v1.3.2/common.gypi#L209-L218) в компонентах кожного.

Ця зміна принесла деякі позитивні побічні ефекти Electron. Перед зміною , не вдалося перейменувати виконуваний файл Electron для Windows, якщо ви використали нативні модулі, тому що ім'я виконуваного файлу було жорстко закодовано в бібліотеці імпорту. Після того, як вузол був побудований в якості спільної бібліотеки, це обмеження було прийнято тому що всі рідні модулі були об'єднані з `вузлом. ll`, чиї ім'я не треба бути змінені.

## Підтримуються нативні модулі

[Нативні модулі](https://nodejs.org/api/addons.html) в вузла працюють шляхом визначення функції запису для завантаження Node, та після, яка шукає символи V8 та лібув з Node. Трохи непокоїть вбудовані об'єкти, тому що за замовчуванням символи V8 і libuv приховані, коли побудова Node як бібліотека, а нативні модулі не зможуть завантажити тому що вони не можуть знайти символи.

Таким чином, щоб зробити власні модулі працювали, символи V8 і libuv показані в Electron. Для V8 це зроблено [всі символи в файлі конфігурації Chromium повинні бути викриті на](https://github.com/electron/libchromiumcontent/blob/v51.0.2704.61/chromiumcontent/chromiumcontent.gypi#L104-L122). Для лібу, його досягнуто за допомогою [встановлення `BUILDING_UV_SHARED=1` визначення](https://github.com/electron/electron/blob/v1.3.2/common.gypi#L219-L228).

## Початковий вузол у вашому додатку

Після всієї роботи будівлі та зв'язку з Node, останній крок виконується Node у вашому додатку.

Вузол не забезпечує великий публічний API для вбудовування себе в інші застосунки. Usually, you can just call [`node::Start` and `node::Init`](https://github.com/nodejs/node/blob/v6.3.1/src/node.h#L187-L191) to start a new instance of Node. Однак, якщо ви створюєте комплексний додаток на основі вузла, ви повинні використовувати такі API як `вузол::CreateEnvironment` , щоб точно контролювати кожен крок.

В Electron, Node запущено в двох режимах: режим автономного, який виконується в основному процесі, який схожий на офіційні бінарні вузла і вбудований режим , який вставляє API вузла на веб-сторінки. Деталі цього буде пояснено у майбутньому повідомленні.

