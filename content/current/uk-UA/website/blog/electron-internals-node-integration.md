---
title: 'Electron Internals: Message Loop Integration'
author: zcbenz
date: '2016-07-28'
---

Це перше повідомлення серії, яка пояснює інтернали Electron. Цей пост показує, як ця подія вузла інтегрується з Chromium в Electron.

---

Було багато спроб використовувати Node для програмування графічного інтерфейсу, наприклад, [node-gui](https://github.com/zcbenz/node-gui) for GTK+ bindings, and [node-qt](https://github.com/arturadib/node-qt) для QT bindings. Але жоден з них не працює у постановці, тому що GUI toolkits має власне повідомлення , поки Node використовує libuv для свого циклу події, і головний потік може одночасно запускати лише один цикл. Так що поширений трюк, який запускає цикл повідомлення графічного інтерфейсу в Node полягає в тому, щоб перекачувати цикл повідомлення таймера з дуже малим інтервалам, який робить реакцію інтерфейсу слабкою та займає багато ресурсів процесора.

Під час розробки Electron ми познайомилися з тією ж проблемою, хоча й зворотнім шляхом: нам довелося інтегрувати цикл подій вузла в цикл повідомлення Chromium .

## Головний процес і процес рендерингу

Перед тим, як зануритися в деталі інтеграції циклів повідомлень, я спочатку поясню багатопроцесну архітектуру Chromium.

У Electron є два типи процесів: основний процес і рендер процес (це насправді дуже спрощено, для повного перегляду, будь ласка, перегляньте [Мульти-процес архітектури](http://dev.chromium.org/developers/design-documents/multi-process-architecture)). Головний процес є відповідальним для графічного інтерфейсу, наприклад, створення вікон, в той час як процес рендерингу працює лише з , запущеним і відтворенням веб-сторінок.

Electron дозволяє використовувати JavaScript для керування основним процесом та рендерингу , що означає, що ми повинні інтегрувати Node в обидва процеси.

## Заміна циклу повідомлень Chromium на libuv

Моя перша спроба - реалізація циклу повідомлення Chromium з libuv.

Для процесу рендеру було легко, оскільки його цикл повідомлення слухали лише дескриптори і таймери, і я повинен був тільки реалізувати інтерфейс з libuv.

А проте це було значно складніше для основного процесу. Кожна платформа має свої власні цикли повідомлень інтерфейсу. macOS Chromium uses `NSRunLoop`, whereas Linux uses glib. I tried lots of hacks to extract the underlying file descriptors out of the native GUI message loops, and then fed them to libuv for iteration, but I still met edge cases that did not work.

Тому нарешті я додав таймер для опитування циклу повідомлення інтерфейсу в невеликому інтервалі. Так результат процес приймав постійне використання ЦП, і певні операції мали довгі затримки.

## Опитування циклу подій вузла в окремій потоці

По мірі того, як дозріла лібу, тоді було можливо застосувати інший підхід.

Концепція backend fd була введена в libuv, що є описом файлу (або вручну), які опитування libuv для циклу своєї події. Саме тому опитування Фд (backend fd) можливе повідомлення при появі нової події у libu.

So in Electron I created a separate thread to poll the backend fd, and since I was using the system calls for polling instead of libuv APIs, it was thread safe. І коли б у циклі події відбулася нова подія, повідомлення буде опубліковане в циклі повідомлень Chromium, і події лібува будуть оброблені в головному потоці.

Таким чином я уникнув патчування Chromium і Node, і той самий код використовувався в як основних, так і рендерингових процесах.

## Код

Ви можете знайти реалізування інтеграції циклу повідомлень в `node_bindings` files under [`electron/atom/common/`](https://github.com/electron/electron/tree/master/atom/common). Так може бути легко використовувати для проектів, що хочуть інтегрувати Node.

