# Продуктивність

Розробники часто запитують про стратегії для оптимізації продуктивності програм Electron. Програмісти, споживачі і фреймворки не завжди погоджуються з одним визначенням того, що означає "продуктивність". Цей документ обзначає деякі улюблені способи обслуговування Electron для зменшення пам'яті, процесора, і дискові ресурси, що використовуються при забезпеченні того, що ваш додаток реагує на дані користувача і завершує операції якомога швидше . Крім того, ми хочемо, щоб усі стратегії продуктивності підтримували високий стандарт безпеки вашого застосунку.

Відома та інформація про те, як створювати ефективні веб-сайти з JavaScript зазвичай застосовуються і до програм Electron. З певною мірою ресурси обговорювати, як побудувати Node. s застосунки застосовуються, але будьте обережні, щоб зрозуміти, що термін "виконання" означає різні речі для Node. s backend ніж для програми, що працює на клієнті.

Цей список надається для вашої зручності - і, подібно до нашого [контрольного списку безпеки](./security.md) - не має значення для вичерпування. Напевно, можливо створити повільний Electron додаток, що виконує всі кроки, викладені нижче. Electron - це потужна платформа розвитку, яка дозволяє вам, розробнику, робити більше або менше що забажаєте. Все, що значить, що свобода означає, що продуктивність значною мірою є вашою відповідальністю.

## Міри, міру в русі

The list below contains a number of steps that are fairly straightforward and easy to implement. При побудові найбільш продуктивної версії додатку ви матимете бажання вийти за рамки декількох кроків. Замість цього вам доведеться уважно вивчити весь код, що працює у вашому застосунку, шляхом ретельного профілювання і вимірювання. Де вузькі місця? Коли користувач натискає кнопку, то як операції захоплюють основний удар часу? У той час як додаток просто обробляє, який об'єкти займають найбільше пам'яті?

Час і час знову ми побачили, що найбільш успішна стратегія побудови застосунка Electron - профілювати запущений код, знайдіть найбільш ресурсоголодний шматок його та оптимізуйте його. Якщо повторити це, здавалося б, трудомісткий процес знову і знову, різко збільшить продуктивність вашої програми Досвід роботи з основними програмами, такими як Visual Studio Code або Slack показав, що ця практика є найнадійнішою стратегією для підвищення продуктивності.

Щоб дізнатися більше про те, як запрофілювати код вашої програми, ознайомтеся з інструментами розробника Chrome. Для детального аналізу програма дивитись на декілька процесів , врахуйте інструмент [трасування Chrome](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool).

### Рекомендоване читання

 * [Почніть з аналізу продуктивності Runtime](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/)
 * [Говоріть: "Visual Studio Code - Перший секунд"](https://www.youtube.com/watch?v=r0OeHRUCCb4)

## Checklist

Шанси є те, що ваш додаток може бути трохи худішим, швидшим та менш ресурсоголодним, якщо ви спробуєте зробити ці кроки.

1. [Без сумніву, включені модулі](#1-carelessly-including-modules)
2. [Завантаження і запуск коду занадто рано](#2-loading-and-running-code-too-soon)
3. [Блокування основного процесу](#3-blocking-the-main-process)
4. [Блокування рендеру процесу](#4-blocking-the-renderer-process)
5. [Непотрібні поліфіли](#5-unnecessary-polyfills)
6. [Непотрібні або блокувати мережеві запити](#6-unnecessary-or-blocking-network-requests)
7. [Набір коду](#7-bundle-your-code)

## 1) Недбало включаючи модулі

Перед додаванням модуля Node.js до вашої програми, перегляньте зазначений модуль. Скільки залежностей буде додано до цього модуля? Якими ресурсами є функція вона просто повинна бути викликана в умові ``? Ви можете знайти , що модуль з найбільшою кількістю завантажень в реєстрі NPM або більшість зірок на GitHub насправді не є одним з найменших доступних або найменшим завантажень.

### Чому?

Свідчення цієї рекомендації найкраще ілюструють з прикладом реального світу . Протягом перших днів Electron, надійне виявлення мережі підключення було проблемою, в результаті багатьох програм використовувати модуль, який повідомляє простий `isOnline()`.

Цей модуль виявив вашу мережу підключення, намагаючись зв'язатися з кількістю відомих кінцевих точок. У списку цих кінцевих точок він залежав від іншого модуля, який також містив список відомих портів. Ця залежність сама покладається на модуль, що містить інформацію про порти, який увійшов у форму JSON файлу з більш ніж 100 000 рядків вмісту. Коли модуль був завантажений (зазвичай в `require('module')` , Це завантажить всі свої залежності і, в кінцевому рахунку, прочитати та розібрати цей файл JSON . Розбір багатьох тисяч рядків JSON - це дуже дорога операція. Виконується повільна машина може зайняти цілі секунди.

У багатьох контекстах сервера час запуску практично не має значення. Вузл. s server , що вимагає інформації про всі порти, ймовірно, "більш продуктивний" , якщо він завантажує всю необхідну інформацію в пам'ять коли сервер завантажується на завантаження корисних запитів швидше. Модуль, що обговорюється в цьому прикладі, це не модуль "bad". Проте застосунки на Electron не повинні завантажуватися, аналізуватися та зберігати в пам'яті відомості, якої це насправді не потрібно.

Коротше кажучи, на перший погляд, відмінний модуль, написаний насамперед для серверів Node.js Лінукс може бути поганим новинами для продуктивності вашого застосунку. Зокрема, приклад правильного рішення полягав у використанні жодного модуля. і замість цього використовувати перевірки з'єднання, які включені в наступні версії Chromium.

### Як?

При розгляді модуля, ми рекомендуємо перевіряти:

1. розмір залежностей включав 2) ресурси, необхідні для завантаження (`вимагає`) це
3. ресурси, необхідні для виконання дії, яка вас цікавить

Генерування профілю ЦП та профілю пам'яті купу зображень для завантаження модуля можна виконати за допомогою єдиної команди у командному рядку. У наведеному нижче прикладі ми переглядаємо популярний модуль `запит`.

```sh
вузол --cpu-prof --heap-prof -e "require('request')"
```

Виконання цієї команди призводить до файлу `.cpuprofile` і файлу `.heappro` в каталозі, в якому ви виконували його. Обидва файли можна аналізувати за допомогою інструментів розробника Chrome, використовуючи `продуктивність` і `вкладки` відповідно.

![performance-cpu-prof](../images/performance-cpu-prof.png)

![performance-heap-prof](../images/performance-heap-prof.png)

У цьому прикладі на машині автор ми побачили, що завантаження `запиту` зайняло майже півсекунди у той час, як `прийняття` потребувало значно менше пам’яті і менше 50 мс.

## 2) Завантаження і запуск коду занадто рано

Якщо у вас є дорогі операції з установкою, подумайте про відкладання. Дослідити всю роботу виконану відразу після початку програми. Замість того, щоб звільняти всі операції відразу, подумайте про складання їх більш тісно пов'язане з поїздкою користувача.

У традиційній розробці Node.js, ми використовуються для розміщення всіх наших `вимог` вгорі. Якщо ви зараз пишете ваш додаток Electron використовуючи ту ж стратегію _і_ використовують великі модулі, які ви не відразу потребуєте, застосовуйте ту ж стратегію та відкладіть завантаження до ще часу.

### Чому?

Завантажувальні модулі є напрочуд дорогою операцією, особливо для Windows. Після початку програми користувач не повинен змушувати користувачів чекати операцій , які в даний час не є необхідними.

Це може здатися очевидним, але багато додатків мають тенденцію до роботи після запуску програми - як перевірка оновлень, завантажити вміст, який використовується в пізнішому потоці або виконувати операції з диском вводу-виводу .

Розгляньмо код Visual Studio як приклад. Коли ви відкриєте файл, це відразу ж відобразить файл вам без підсвітки коду, прибираючи вашу можливість взаємодіяти з текстом. Після виконання цієї роботи він рухатиметься до виділення коду.

### Як?

Давайте розглянемо приклад і припустимо, що ваш додаток аналізує файли у вигаданому форматі `.foo`. Для цього він покладається на модуль на менш вигаданий модуль `foo-parser`. В традиційній розробці Node.js ви можете написати код, який жадібно завантажує залежності:

```js
const fs = require('fs')
const fooParser = require('foo-parser')

class Parser {
  constructor () {
    this. iles = fs.readdirSync('. )


  getParsedFiles () {
    return fooParser.parse(це. iles)
  
 }
}

const parser = new Parser()

module.export = { parser }
```

Наприклад, під час завантаження файлу виконується багато роботи. Як тільки цей файл буде завантажено. Нам потрібно відразу ж розібрати файли? Could we do this work a little later, when `getParsedFiles()` is actually called?

```js
// "fs", ймовірно, вже завантажується, таким чином виклик `require()` є дешевим
const fs = require('fs')

class Parser {
  async getFiles () {
    // Доторкніться диску, як тільки `getFiles` буде викликано, не раніше.
    // Також переконайтеся, що ми не блокуємо інші операції використовуючи
    // асинхронну версію.
    this.files = this.files || await fs.readdir('.')

    повернути це. iles
  }

  async getParsedFiles () {
    // Наші вигадані foo-parser є великим і дорогим модулем для завантаження, так
    // захисник, який працює, поки нам насправді не потрібно аналізувати файли.
    // Since `require()` comes with a module cache, the `require()` call
    // will only be expensive once - subsequent calls of `getParsedFiles()`
    // will be faster.
    const fooParser = require('foo-parser')
    const files = await this.getFiles()

    return fooParser. arse(files)
  }


// Ця операція зараз набагато дешевша, ніж у нашому попередньому прикладі
conser = new Parser()

. xports = { parser }
```

Коротше кажучи, виділіть ресурси "тільки вчасно", а не розподіляйте їх на , коли почнеться ваш додаток.

## 3) Блокування основного процесу

Головний процес Electron (іноді званий "процес браузера") є особливим: батьківський процес для інших процесів вашого додатку та основний процес операційної системи. Він обробляє вікна, взаємодії і зв'язок між різними компонентами всередині вашої програми. Він також має потоку.

Ні за яких обставин ви не повинні блокувати цей процес і стиль інтерфейсу з довготривалими операціями. Блокування теми інтерфейсу означає, що весь додаток буде заморожуватися, поки основний процес не буде готовий до продовження роботи.

### Чому?

Головний процес та його обговорення по суті є контрольною вежею для основних операцій в програмі. Коли операційна система повідомляє вашому додатку про клацання мишкою, він буде проходити основний процес, перш ніж він досягне вашого вікна. Якщо ваше вікно показує анімацію метелика, Поговорити про це з процесом GPU - ще раз пройде основний процес.

Electron та Chromium обережно ставлять операції з диском I/O та CPU-пов'язані на нові потоки, щоб уникнути блокування теми інтерфейсу. Тобі слід зробити те саме.

### Як?

Потужна багатопроцесна архітектура Electron готова допомогти вам у ваших довготривалих завданнях, але також містить невелику кількість пасток продуктивності.

1) Для тривалих запущених ЦП важких завдань, використовуйте [робочі потоки](https://nodejs.org/api/worker_threads.html), Розгляньте можливість переміщення їх до BrowserWindow, або (останнє повторне завантаження) для автоматичного створення виділеного процесу.

2) Уникайте використання синхронного IPC і `віддаленого` модуля наскільки можливо. Під час використання цілком прийнятних випадків, блокувати теми інтерфейсу користувача за допомогою `віддаленого`.

3) Уникайте блокування операцій вводу/виводу в головному процесі. Коротше кажучи, коли базовий вузол. s модулей (як `fs` or `child_process`) пропонують синхронну або асинхронну версію, ви повинні віддати перевагу асинхронному і не блокую варіанту.


## 4) Блокування процесу рендеру

З часу кораблі Electron з поточною версією Chrome, ви можете використовувати найновіші і найновіші функції веб-платформи, які дозволяють відкласти або не завантажувати важкі дії таким чином, щоб ваш додаток міг легко бути активним.

### Чому?

Ваш додаток, ймовірно, має багато JavaScript для запуску в процесі рендеру. The trick is to execute operations as quickly as possible without taking away resources needed to keep scrolling smooth, respond to user input, or animations at 60fps.

Оркестр процесу операцій у коді візуалізатора особливо корисний, якщо користувачі скаржаться на те, що ваш додаток іноді "заїкається".

### Як?

Взагалі кажучи, усі поради щодо створення продуктивних веб-додатків для сучасних браузерів також застосовуються до рендеру Electron. Два первинних інструменти у вашому утилізації наразі є `запитом IdleCallback()` для невеликих операцій і `Веб Workers` для довгострокових операцій.

*`requestIdleCallback()`* дозволяє розробникам об'єднати функцію, яка буде виконана, як тільки процес набуває простою. Це дозволяє виконувати роботу з низьким пріоритетом або фоном без впливу на досвід. Для отримання додаткової інформації про те, як його використовувати [перегляньте свою документацію на MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback).

*Веб-робітники* є потужним інструментом для запуску коду на окремій потоці. Існує деякі застереження, які слід врахувати - зверніться до Electron [багатомовної документації](./multithreading.md) та [документації MDN для Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers). Це ідеальний розв'язок для будь-якої операції, яка потребує великої потужності процесора протягом тривалого періоду часу.


## 5) Непотрібні поліфіли

Однією з чудових переваг Electron є те, що саме двигун буде аналізувати ваш JavaScript, HTML та CSS. Якщо ви переробили код, який записаний для широкого мережі, не забудьте про властивості поліполя, що включені в Electron.

### Чому?

При створенні веб-додатку для сьогоднішнього Інтернету, найстаріші середовища визначають, які функції ви можете чи не можете використовувати. Незважаючи на те, що Electron підтримує добре справлятися з CSS фільтрами та анімації, старий браузер може бути таким. Де ви можете використовувати WebGL, ваші розробники можуть вибрати більш ресурсоголодне рішення для підтримки старих телефонів.

Коли йдеться про JavaScript, Ви, можливо, включили бібліотеки інструментаріїв, наприклад jQuery для DOM selectors або поліфутерів, як `регенератор-runtime` щоб підтримати `async/await`.

It is rare for a JavaScript-based polyfill to be faster than the equivalent native feature in Electron. Не сповільнюйте доставку Вашої власної версії стандартних веб-платформ.

### Як?

Працюйте згідно з припущенням, що полізаповнення у поточних версіях Electron є зайвими. If you have doubts, check [caniuse.com](https://caniuse.com/) and check if the [version of Chromium used in your Electron version](../api/process.md#processversionschrome-readonly) supports the feature you desire.

Крім того, ретельно перевіряйте бібліотеки, які ви використовуєте. Вони насправді необхідні? `jQuery`, for example, was such a success that many of its features are now part of the [standard JavaScript feature set available](http://youmightnotneedjquery.com/).

Якщо ви використовуєте транспілятор/компілятор, як TypeScript, перевірте конфігурацію і переконайтеся, що ви використовуєте останню версію ECMAScript підтримувану Electron.


## 6) Непотрібні або блокують мережеві запити

Уникайте завантаження рідко змінювати ресурси з Інтернету, якщо вони можуть легко бути зібрані з вашим додатком.

### Чому?

Багато користувачів Electron починаються з повністю веб-додатку, що базується на системах, перетворюються на настільний додаток. Як веб-розробники, ми використовуємо для завантаження ресурсів з різних мереж доставки контенту. Тепер, коли ви відправляєте належну програму для робочого столу, спроба "зрізати корд", де можливо і уникати дозволу користувачам чекати на ресурси, які ніколи не змінюються, і можуть легко бути включені в додаток.

Типовий приклад - шрифти Google. Багато розробників використовують вражаючу колекцію вільних шрифтів, що відбувається з мережею доставки контенту . Висота є простою: додайте кілька рядків CSS і Google , будуть розглядатися про решту.

Створюючи додаток Electron, ваші користувачі краще обслуговуються, якщо ви завантажите шрифти і вставте їх у вузол вашого застосунку.

### Як?

В ідеальному світі вашій програмі не потрібно буде користуватися мережею для роботи взагалі. Щоб туди дістатися, ви повинні зрозуміти, які ресурси завантажується програма \- і які розміри цих ресурсів.

Для цього відкрийте інструменти розробника. Перейдіть на вкладку `Мережа` і перевірте `Вимкніть параметр`. Далі перезавантажте рендеринг. Якщо ваш додаток не відповідає такому перевантаженню, зазвичай ви можете запустити перезавантаження шляхом натискання на `Cmd + R` або `Ctrl + R` за допомогою інструментів розробника у фокусі.

Тепер інструменти будуть ретельно записувати всі мережеві запити. По-перше, спочатку на складі всіх завантажуваних ресурсів, зосереджуючись на більших файлах . Are any of them images, fonts, or media files that don't change and could be included with your bundle? Якщо так, включіть їх.

На наступному кроці увімкніть `налаштування мережі`. Знайдіть випадаючий список , який зараз читає `онлайн` і оберіть повільнішу швидкість, таку як `Fast 3G`. Reload your renderer and see if there are any resources that your app is unnecessarily waiting for. У багатьох випадках додаток буде чекати завершення мережевого запиту на , незважаючи на те, що він не потребує підключених ресурсів.

Як порада, завантаження ресурсів з Інтернету, яке, можливо, ви захочете змінити без відправлення оновлення додатка - це потужна стратегія. Для досвідченого контролювати завантаження ресурсів, подумайте про інвестиції в [Service Workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API).

## 7) Набір коду

Як вже вказано в "[Завантаження і запуск коду занадто швидко](#2-loading-and-running-code-too-soon)", виклик `require()` є дорогою операцією. Якщо ви можете це зробити, об'єднайте код вашого додатку в єдиний файл.

### Чому?

Сучасний розвиток JavaScript зазвичай включає в себе багато файлів і модулів. В той час як це чудово підходить для розробки з Electron, ми наполегливо рекомендуємо зібрати весь свій код в один файл, щоб впевнитись, що накладні витрати , включені в виклик `, повертає` платять лише один раз, коли ваша програма завантажується.

### Як?

Існують численні пакети JavaScript там і ми знаємо краще ніж роздратувати спільноту, рекомендуючи один інструмент над іншим. Ми рекомендуємо використати пакет, який здатний обробляти унікальне середовище Electron, яке має обробляти обидва Нод. s і середовища браузера.

Як написано цю статтю, найпопулярніший варіант містить [Webpack](https://webpack.js.org/), [Parcel](https://parceljs.org/)та [rollup.js](https://rollupjs.org/).
