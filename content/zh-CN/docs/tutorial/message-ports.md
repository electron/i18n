# 电子信息端口

[`MessagePort`][]是一个网络功能，允许在 不同的上下文之间传递消息。 这就像 `window.postMessage`，但在不同的渠道。 本文档的目的是描述 Electron 如何扩展通道 消息传递模型，并举出一些示例，说明您如何在应用 使用消息端口。

下面是一个非常简短的示例，说明什么是消息端口以及它的工作原理：

```js
渲染器.js/
/ 连接的消息端口
//称为通道。
const通道=新的消息通道（）

//端口1和端口2之间的唯一区别在于您如何使用它们。 
//发送到端口1的消息将由端口2接收，反之亦然。
const端口1=通道。port1
端口2=通道。port2

//在另一端注册
//听众之前，可以在另一端在通道上发送消息。 消息将排队，直到听众注册。
端口2.邮资（{ answer: 42 }）

//在这里，我们发送通道的另一端，端口1，到主要过程。 也可以
//向其他帧发送消息端口，或发送到 web 工作人员等，
ipcRenderer.后信息（"端口"，空， [port1]）
```

```js
主要.js/
/在主要过程中，我们接收端口。
ipcMain.on（"端口"，（事件）=> {
  //当我们在主要过程中收到消息端口时，它就变成了
  //消息端口。
  端口=事件。端口[0]

  //消息端口主要使用节点.js式事件API，而不是
  //网络式事件API。 所以.on（"消息"，...）而不是。信息=...
  端口。on（"消息"，（事件）=> {
    //数据 { answer: 42 }
    连续数据=事件。数据
  }）

  //消息端口在呼叫。start（）方法之前一直在排队消息。
  端口。开始（）
}）
```

[渠道消息 API][] 文档是了解 消息端口工作方式的好方法。

## 主要过程中的信息端口

在渲染器中， `MessagePort` 类的行为与网络上的行为完全一致。 主要的过程不是一个网页，虽然-它没有闪烁集成-所以 它没有 `MessagePort` 或 `MessageChannel` 类。 In order to handle and interact with MessagePorts in the main process, Electron adds two new classes: [`MessagePortMain`][] and [`MessageChannelMain`][]. 这些行为 类似于渲染器中的类似类。

`MessagePort` 对象可以在渲染器或主 过程中创建，并使用 [`ipcRenderer.postMessage`][] 和 [`WebContents.postMessage`][] 方法来回传递。 请注意，通常的 IPC 方法（如 `send` 和 `invoke` ）不能用于传输 `MessagePort`，只有 `postMessage` 方法可以转移 `MessagePort`。

通过通过主过程传递 `MessagePort`，您可以连接两页，否则 可能无法进行通信（例如，由于同源 限制）。

## 扩展： `close` 活动

电子为网络上不存在的 `MessagePort` 添加了一个功能， 使消息端口更有用。 这是 `close` 事件，当通道的另一端关闭时，该事件 发出。 港口也可以 通过收集垃圾而隐性关闭。

在渲染器中，您可以通过分配给 `port.onclose` 或致电 `port.addEventListener('close', ...)`来收听 `close` 事件。 在主要 过程中，您可以通过呼叫 `
端口来收听``close` 事件。

## 示例使用案例

### 工人流程

在此示例中，您的应用具有作为隐藏窗口实现的工人流程。 您希望应用页面能够 过程直接与工作人员通信，而无需通过主流程进行中继的性能开销。

```js
主要.js/
/浏览器窗口， 应用程序，ipcMain，消息通道主要==需要（'电子'）

应用程序。当准备（然后（不对称）=> {
  //工作人员过程是一个隐藏的浏览器窗口，以便它将能够访问
  //到一个完整的闪烁上下文（例如 <canvas>、音频、取件等）
  const 工作人员 = 新的浏览器窗口 （+
    显示： 虚假的、
    的 WebPrepres： { nodeIntegration: true }
  [）
  等待工人。loadfile （"工人.html"）

  // 主窗口将向工作人员流程发送工作，并在消息端口
  // 收到结果。
  const主窗口=新浏览器窗口（+
    网络预示： { nodeIntegration: true }
  }）
  主窗口。loadFile（"应用程序.html"）

  //我们不能在这里使用ipcMain.handle（），因为回复需要转移
  //消息端口。
  ipcMain.on（"请求-工作人员通道"，（事件）=> {
    //出于安全原因，让我们确保只有我们期望的帧可以
    //访问工人。
    如果（事件.发送框==主窗口.网络主机）{
      //创建一个新的通道...
      康斯特 { port1, port2 } =新的消息通道（）
      //将一端发送给工人...
      工人.web康滕茨.邮资信息（"新客户端"，空， [port1]）
      //。。。和主窗口的另一端。
      事件。发送框.后信息（'提供-工人通道'，空， [port2]）
      //现在的主要窗口和工人可以相互沟通
      //没有经过主要过程！
    [
  }）
}）
```

```html<!--工人.html ------------------------------------------------------------><script>
康斯特 { ipcRenderer } =需要（'电子'）

功能做工作（输入）{
  //一些cpu密集型的东西。
  返回输入*2
}

//我们可能会得到多个客户端，例如，如果有多个窗口，
//或如果主窗口重新加载。
ipcRenderer.on（"新客户端"，（事件）=> {
  端口[端口]=事件。端口
  端口。信息=（事件）=> {
    //事件数据可以是任何可串行的对象（事件甚至可以
    //随身携带其他消息端口！
    结果=端口
    工作（事件.数据）。邮寄信息（结果）
  }
}）
</script>
```

```html<!--应用程序.html ---------------------------------------------------------------><script>
const { ipcRenderer } =要求（'电子'）

//我们要求主过程向我们发送一个通道，我们可以使用
//与工作人员沟通。
ipcRenderer.发送（"请求-工人通道"）

ipcRenderer.once（"提供工人通道"，（事件）=> {
  //一旦我们收到回复，我们可以采取端口。。。
  康斯特[端口]=事件。端口
  //注册一个处理程序来接收结果...
  端口.onmesage=（事件）=> {
    控制台.log（收到的结果：'，事件.数据）
  }
  //并开始发送它的工作！
  港口.邮资信息（21）
}）
</script>
```

### 回复流

电子的内置 IPC 方法仅支持两种模式：火与忘记 （例如 `send`），或请求响应（例如 `invoke`）。 使用消息通道，您 可以实现"响应流"，其中单个请求会以 数据流进行响应。

```js
渲染器.js/

/ 回调）{
  //消息通道是轻量级的-为每个
  //请求创建一个新的通道很便宜。
  康斯特 { port1, port2 } =新的消息通道（）

  //我们发送端口的一端到主要过程。。。
  ipcRenderer.邮递信息（
    "给我一个流"，
    { element, count: 10 }，
    [port2]
  ）

  //我们坚持到另一端 主过程将
  //发送消息到端口的末端，并在端口完成后将其关闭。
  端口1.图像=（事件）=> {
    回调（事件.数据）
  }
  端口1.关闭=（）=> {
    控制台.log（"流结束"）
  }
}

进行流式传输要求（42， （数据）=> =
  控制台.log（'得到响应数据：'，事件.数据）
}）
//我们将看到"获得响应数据：42"10次。
```

```js
主要.js

（事件，msg）=> {
  //渲染器向我们发送了一个消息端口，它希望我们发送我们的
  //响应结束。
  const [replyPort] =事件。端口

  //在这里，我们同步发送消息，但我们可以同样轻松地将
  //端口存储在某处并异步发送消息。
  （让我=0;我 < msg.count;i+）{
    回复波特.邮资信息（msg.element）
  }

  //当我们完成指示到另一端，我们
  //不会再发送任何消息时关闭端口。 这不是绝对必要的 - 如果我们
  //没有明确关闭端口，它最终将是垃圾
  //收集，这也将触发渲染器中的"关闭"事件。
  回复港口关闭（）
}）
```

### 直接在上下文隔离页面的主要过程和主世界之间进行通信

启用 [上下文隔离][] 时，从主过程到渲染器 IPC 消息将传递到孤立的世界，而不是主要 世界。 有时，您希望直接向主要世界传递信息， 而不必跨过孤立的世界。

```js
主要.js/
/ { BrowserWindow, app, MessageChannelMain }
需要（"电子"）

应用时，需要（"路径"）然后（对> ）=
  //创建启用上下文隔离的浏览器窗口。
  const bw=新的浏览器窗口（{
    网络自尊：{
      上下文自焚：真实，
      预加载：path.__dirname，"预加载.js"）
    =
  }）
  bw.loadURL（"索引.html"）

  //我们将将此通道的一端发送到
  //上下文隔离页面的主要世界。
  康斯特 { port1, port2 } =新的消息通道main（）

  //在另一端
  //注册了听众之前在频道上发送消息是可以的。 消息将排队，直到
  //注册。
  port2.后信息（{ test: 21 }）

  //我们也可以接收来自渲染器主要世界的消息。
  端口2.on（"消息"，（事件）=> {
    控制台.log（"从渲染器主世界：'，事件.数据）
  }）
  端口2.开始（）

  //预加载脚本将接收此IPC消息，并将端口
  //转移到主世界。
  bw.web康滕茨.邮资信息（"主世界端口"，空， [port1]）
}）
```

```js
预装.js/
 { ipcRenderer } =需要（"电子"）

//我们需要等到主世界准备好接收消息后再
//发送端口。 我们在预加载中创建此承诺，因此保证
//在加载事件被激发之前注册加载侦听器。
收缩窗口加载 = 新承诺 （解决 => {
  窗口.加载 = 解决
[）

ipcRenderer. on （"主世界端口"， 不对称 （事件） => {
  等待窗口加载
  / / 我们使用常规窗口
  。
  窗口.邮资信息（"主世界端口"，"*"，"事件"）
}）
```

```html<!--索引.html -------------------------------------------------------------><script>
窗口。onmesage = （事件） => =
  // 事件 <iframe> 
  。
  如果（事件.来源==窗口 && 事件.data=="主世界端口"）{
    端口[端口]=事件。端口
    //一旦我们有了端口，我们可以直接与主
    //过程进行通信。
    端口.onmesage=（事件）=> =
      控制台.log（"从主要过程：'，事件.数据）
      端口。邮寄信息（事件.数据*2）
    }
  }
=
</script>
```

[上下文隔离]: context-isolation.md
[`ipcRenderer.postMessage`]: ../api/ipc-renderer.md#ipcrendererpostmessagechannel-message-transfer
[`WebContents.postMessage`]: ../api/web-contents.md#contentspostmessagechannel-message-transfer
[`MessagePortMain`]: ../api/message-port-main.md
[`MessageChannelMain`]: ../api/message-channel-main.md
[`MessagePort`]: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort
[渠道消息 API]: https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API
