# Нумерация версий Electron

> Детализированный взгляд на политику версионирования и ее реализацию.

По версии 2.0.0, Electron следует [SemVer](#semver). Следующая команда установит последнюю стабильную сборку Electron:

```sh
npm install --save-dev electron
```

Обновление до последней стабильной версии в существующем проекте:

```sh
npm install --save-dev electron@latest
```

## Версия 1.x

Электронные версии *< 2.0* не соответствовали спецификации [SemVer](https://semver.org) : основные версии соответствовали изменениям API конечных пользователей, второстепенные версии соответствовали крупным релизам Chromium, а версии патчей соответствовали новым функциям и исправлениям ошибок. Удобно для разработчиков при объединении возможностей, но это создает проблемы для разработчиков пользовательских приложений. Циклы тестирования QA основных приложений, таких как Slack, Stride, Teams, Skype, VS Code, Атомные и настольные компьютеры могут быть длительными, а стабильность является весьма желаемым результатом. Существует большой риск применения новых функций при использовании исправлений ошибок.

Вот пример стратегии 1.x:

![1.x Версия](../images/versioning-sketch-0.png)

Приложение разработанное с `1.8.1` не может взять `1. .3` исправление ошибок без поглощения `1. .2` особенность, или backporting the fix and maintenance of new release line.

## Версия 2.0 и выше

Ниже приводится несколько важных изменений в нашей стратегии 1.x. Каждое изменение предназначено для удовлетворения потребностей и приоритетов разработчиков/сопровождающих и разработчиков приложений.

1. Строгое использование SemVer
2. Введение в теги `-beta`
3. Введение [обычных сообщений о коммитах](https://conventionalcommits.org/)
4. Хорошо определенные ветви стабилизации
5. Версия ветки `master` недоступна. Только стабилизирующие ветви содержат информацию о версии

Мы подробно рассмотрим как работает ветка git, как работает npm тег, что разработчики должны видеть и как можно изменить backport.

# СемВер

С 2.0 и далее Electron будет следовать за SemVer.

Ниже приведена таблица, в котором явно отображаются типы изменений в соответствующую категорию SemVer (например, Major, Minor, Patch).

| Основные версии                    | Незначительные увеличения версии      | Увеличить версию патча          |
| ---------------------------------- | ------------------------------------- | ------------------------------- |
| Electron разрыв API изменения      | Изменения в Electron небезопасном API | Исправления ошибок Electron     |
| Обновление основных версий Node.js | Node.js обновления младшей версии     | Обновления версии патча Node.js |
| Обновления версии Chromium         |                                       | патчи с хромовым фиксированием  |

Обратите внимание, что большинство обновлений Chromium будет считаться перерывом. Исправления, которые могут быть обратно будут выбраны в качестве патчей.

# Стабильные ветки

Стабилизационные ветви - это ветки, которые управляют параллельно с освоением, принимая только вишневые коммиты, связанные с безопасностью или стабильностью. Эти ветки никогда не сливаются с мастером.

![Стабильные ветки](../images/versioning-sketch-1.png)

Начиная с Electron 8, ветки стабилизации всегда **основные версии** линий, и названы в соответствии с следующим шаблоном `$MAJOR-x-y` e. . `8-x-y`.  До этого мы использовали **мелкие** строк версии и назвали их `$MAJOR-$MINOR-x` , например `2-0-x`

Мы позволяем многократным стабилизационным ветвям существовать одновременно, и намерена поддерживать как минимум два параллельных в любое время, при необходимости резервные исправления безопасности. ![Несколько ветвей стабильности](../images/versioning-sketch-2.png)

Более старые линии не будут поддерживаться GitHub, но другие группы могут самостоятельно брать на себя права собственности и backport стабильности и исправления безопасности. Мы не поощряем это, но понимаем, что это упрощает жизнь для многих разработчиков приложений.

# Бета-релизы и исправление багов

Разработчики хотят знать, какие релизы являются _безопасными_ для использования. Даже невинные характеристики могут привести к регрессии в сложных приложениях. В то же время, блокировка исправленной версии опасна, так как вы игнорируете патчи безопасности и исправления ошибок, которые могут появиться с момента окончания вашей версии. Наша цель - разрешить следующие стандартные диапазоны semver в `package.json`:

* Используйте `~2.0.0` для допущения исправления только стабильности или связанных с безопасностью исправлений к вашему релизу `2.0.0`.
* Используйте `^2.0.0` для принятия неспокойной _разумно стабильной работы_ , а также исправлений безопасности и ошибок.

Во втором случае приложения, использующие `^` , все еще должны иметь возможность ожидать приемлемого уровня стабильности. Для достижения этой цели SemVer позволяет _идентификатор предварительного релиза_ указать, что конкретная версия еще не _безопасна_ или _стабильна_.

Независимо от того, что вы выбрали, вам периодически придется загружать версию в `package.json` , так как нарушение изменений является фактом жизни Chromium.

Этот процесс является следующим:

1. Все новые основные и незначительные релизы линии начинаются с бета-серии, указанной SemVer prerelease теги `beta.N`, например. `2.0.0-beta.1`. After the first beta, subsequent beta releases must meet all of the following conditions:
    1. Изменение обратного API-совместимо (допускается устаревание)
    2. Риск соблюдения сроков стабильности должен быть низким.
2. Если допустимые изменения необходимо внести после выпуска бета-версии, то они применяются и увеличивается тэг prerelease, e. . `2.0.0-beta.2`.
3. If a particular beta release is _generally regarded_ as stable, it will be re-released as a stable build, changing only the version information. например, `2.0.0`. После первой стабильности, все изменения должны быть обратно совместимыми с ошибками или исправлениями безопасности.
4. If future bug fixes or security patches need to be made once a release is stable, they are applied and the _patch_ version is incremented e.g. `2.0.1`.

В частности, вышеуказанное означает:

1. Прием не-брейк-API изменения до недели 3 в бета-цикле в порядке, даже если эти изменения имеют потенциал, чтобы вызвать умеренные побочные эффекты.
2. Внесение изменений в функционал, которые в противном случае не изменяют существующие пути кода, в большинстве точек в бета-цикле нормально. Пользователи могут явно включать эти флаги в своих приложениях.
3. Добавляются возможности любого рода после 3-й недели в бета-цикле 👎 без очень хорошей причины.

По каждому главному и второстепенному шару, вы должны ожидать что-то вроде следующих:

```plaintext
2.0.0-beta.1
2.0.0-beta.2
2.0.0-beta.3
2.0.0
2.0.1
2.0.2
```

Пример жизненного цикла изображений:

* Создана новая ветка релиза, включающая в себя последний набор функций. Он опубликован как `2.0.0-beta.1`. ![Новая ветвь выпуска](../images/versioning-sketch-3.png)
* Исправление ошибки входит в мастер, который может быть обращен в ветку выпуска. Патч применяется, и новая бета-версия опубликована как `2.0.0-beta.2`. ![Багфикс Бэкпорт в бета-версию](../images/versioning-sketch-4.png)
* The beta is considered _generally stable_ and it is published again as a non-beta under `2.0.0`. ![Бета в конюшню](../images/versioning-sketch-5.png)
* Позднее обнаруживается нулевой эксплойт и к мастеру применяется фиксация. Мы возвращаем исправление на линию `2-0-x` и релиз `2.0.1`. ![Бэкпорты безопасности](../images/versioning-sketch-6.png)

Несколько примеров того, как различные диапазоны SemVer будут собирать новые релизы:

![Semvers и релизы](../images/versioning-sketch-7.png)

# Отсутствующие возможности: Альпийский

Наша стратегия имеет несколько компромиссов, которые на сегодняшний день мы считаем подходящими. Самое важное, что новые возможности в master могут занять некоторое время до достижения стабильной линии выпуска. Если вы хотите сразу же попробовать новую функцию, вам придется создать Electron самостоятельно.

В качестве будущего рассмотрения мы можем представить одно или оба из нижеследующих:

* alpha releases that have looser stability constraints to betas; for example it would be allowable to admit new features while a stability channel is in _alpha_

# Функциональные флаги

Флаги свойств являются общей практикой в Chromium, и хорошо зарекомендовали себя в экосистеме веб-разработки. In the context of Electron, a feature flag or **soft branch** must have the following properties:

* включено/отключено либо во время выполнения, либо во время сборки; мы не поддерживаем концепцию флага функции с охватом запроса
* it completely segments new and old code paths; refactoring old code to support a new feature _violates_ the feature-flag contract
* флаги фиксации в конце концов удаляются после выхода функции

# Семантические коммиты

Мы стремимся к повышению четкости на всех уровнях процесса обновления и выпуска. Начиная с `2.0.0` , нам потребуется придерживаться спецификации [Обычные Коммиты](https://conventionalcommits.org/) для pull-запросов, которая может быть обобщена следующим образом:

* Обязательства, которые приведут к SemVer **основной** удар должен начать свое тело с `BREAKING CHANGE:`.
* Обязательства, которые приведут к SemVer **незначительные** удар должен начаться с `feat:`.
* Обязательства, которые приведут к SemVer **патч** удар должен начаться с `fix:`.

* Мы разрешаем размывать коммиты при условии, что это сообщение приближается к указанному выше формату сообщения.
* Допустимо наличие некоторых фиксаций в pull-запросе, чтобы он не включал семантический префикс, до тех пор, пока заголовок Pull Request содержит значимое охватывающее семантическое сообщение.

# Версия `master`

* Ветка `master` всегда будет содержать следующую основную версию `X.0.0-nightly.DATE` в `package.json`
* Отпустить ветки никогда не сливаются с master
* Release branches _do_ contain the correct version in their `package.json`
* Как только выпускная ветка будет перерезана на основной, мастер должен быть доставлен к следующему основному.  Например. `master` всегда версии в качестве следующей теоретической ветви релиза
