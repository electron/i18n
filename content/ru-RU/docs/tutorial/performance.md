# Характеристика

Разработчики часто спрашивают о стратегиях оптимизации производительности приложений Electron. Les ingénieurs, les consommateurs et les développeurs de framework ne sont pas toujours d'accord sur une seule définition de ce que signifie "performance". В этом документе описаны любимые способы уменьшения количества памяти, процессора и дисковые ресурсы, используемые при условии, что ваше приложение реагирует на входные данные пользователя и выполняет операции как можно быстрее . Более того, мы хотим, чтобы все стратегии производительности поддерживали высокий стандарт для безопасности вашего приложения.

Мудрость и информация о том, как создавать производительные сайты с JavaScript обычно применимы и к Electron. To a certain extent, resources discussing how to build performant Node.js applications also apply, but be careful to understand that the term "performance" means different things for a Node.js backend than it does for an application running on a client.

This list is provided for your convenience – and is, much like our [security checklist][security] – not meant to exhaustive. Вероятно, для создания медленного приложения Electron, которое следовало бы всем шагам, описанным ниже. Electron — это мощная платформа для разработки, позволяющая разработчикам делать больше или меньше того, что вы хотите. Вся эта свобода означает, что производительность в значительной степени вашей ответственности.

## Измерение, Измерение, Измерение

В приведенном ниже списке содержится ряд шагов, которые достаточно просты и легко осуществить. Тем не менее, создание наиболее эффективной версии вашего приложения потребует вас выйти за рамки нескольких шагов. Вместо этого вам придется внимательно изучить весь код, работающий в вашем приложении, тщательно профилируя и измеряя его. Где узкие места? Когда пользователь нажимает на кнопку, какие операции занимают основное время? Пока приложение не работает, какие объекты занимают самую память?

Время и снова, мы видели, что наиболее успешная стратегия создания производительного Electron приложения заключается в профиле выполняемого кода, найдите наиболее часть из голодных ресурсов и оптимизируйте его. Повторение этого кажущегося трудового процесса снова и снова резко увеличит производительность вашего приложения. Опыт работы с основными приложениями, такими как Visual Studio Code или Slack показал, что эта практика является самой надежной стратегией повышения производительности.

Чтобы узнать больше о том, как прочитать код вашего приложения, ознакомьтесь с Инструментами разработчика Chrome. Для расширенного анализа, глядя на несколько процессов сразу, попробуйте инструмент [Отслеживание](https://www.chromium.org/developers/how-tos/trace-event-profiling-tool) Chrome Tracing.

### Рекомендуемое чтение

* [Начните с анализа производительности Runtime Performance][chrome-devtools-tutorial]
* [Говорить: "Визуальный код студии - первая секунда"][vscode-first-second]

## Checklist

Шанс на то, что ваше приложение может быть немного лечим, быстрее и в целом менее ресурсов, если вы пытаетесь эти шаги.

1. [Безвозвратно включая модули](#1-carelessly-including-modules)
2. [Загрузка и запуск кода слишком скоро](#2-loading-and-running-code-too-soon)
3. [Блокирование главного процесса](#3-blocking-the-main-process)
4. [Блокировка процесса рендерера](#4-blocking-the-renderer-process)
5. [Необязательные полифилы](#5-unnecessary-polyfills)
6. [Нет необходимости или блокирует сетевые запросы](#6-unnecessary-or-blocking-network-requests)
7. [Составь свой код](#7-bundle-your-code)

## 1) Безвозвратно включая модули

Перед добавлением модуля Node.js к вашему приложению, изучите этот модуль. How many dependencies does that module include? Какие ресурсы нужно просто вызвать в выражении `require()`? Вы можете найти , что модуль с наибольшим количеством загрузок в реестре пакетов NPM или большинство звезд на GitHub , по сути, не является наименьшим из доступных.

### Почему?

Основания этой рекомендации лучше всего иллюстрировать реальным примером . During the early days of Electron, reliable detection of network connectivity was a problem, resulting many apps to use a module that exposed a simple `isOnline()` method.

Этот модуль обнаружил ваше сетевое подключение, пытаясь добраться до числа хорошо известных конечных точек. Для списка этих конечных точек он зависит от другого модуля, который также содержит список известных портов. Эта зависимость полагается на модуль, содержащий информацию о портах, , который был в виде JSON файла с более чем 100 000 строк содержимого. Каждый раз, когда модуль был загружен (обычно в инструкции `require('module')` ), он загрузит все его зависимости и в конечном итоге прочитал и разобрал этот JSON файл. Обработка многих тысяч линий JSON - это очень дорогая операция. На медленной машине может занять несколько секунд времени.

Во многих контекстах серверов время запуска практически не имеет значения. Узел. , сервер , который требует информацию обо всех портах, скорее всего, "большей производительности" , если он загружает всю необходимую информацию в память при загрузке сервера с выгодой более быстрого обслуживания запросов. Модуль, обсуждаемый в этом примере, не «плохо» модуль. Тем не менее, Electron приложения не должны загружаться, анализировать и хранить в памяти информацию, которая на самом деле не нужна.

Короче говоря, отличный модуль, написанный главным образом для серверов Node.js с запущенной Linux может привести к плохим новостям для производительности вашего приложения. В данном конкретном примере правильным решением было не использовать модуль вообще, , чтобы использовать проверки на подключение, включенные в более поздних версиях Chromium.

### Как?

При рассмотрении модуля мы рекомендуем проверить:

1. the size of dependencies included
2. the resources required to load (`require()`) it
3. ресурсы, необходимые для выполнения интересующих вас действий

Создание профиля ЦП и профиля памяти кучи для загрузки модуля может быть сделано с помощью одной команды в командной строке. В приведенном ниже примере мы рассмотрим популярный модуль `запрос`.

```sh
node --cpu-prof --heap-prof -e "require('request')"
```

Выполнение этой команды приводит к появлению файла `.cpuprofile` и файла `.heapprofile` в папке, в которой вы его запустили. Both files can be analyzed using the Chrome Developer Tools, using the `Performance` and `Memory` tabs respectively.

![Performance CPU Profile][4]

![Performance Heap Memory Profile][5]

В этом примере на машине автора мы увидели, что загрузка `запроса` заняла почти половину секунды, в то время как `node-fetch` занимал значительно меньше памяти и менее 50 мс.

## 2) Загрузка и запуск кода слишком скоро

Если у вас есть дорогие операции установки, подумайте о переносе их на более поздний срок. Проверяйте всю работу , выполняемую сразу после запуска приложения. Вместо того, чтобы сразу выстреливать , рассмотрите возможность оглушения их в последовательности близко к путешествию пользователя.

В традиционной разработке Node.js мы используем все наши `require()` операторы вверху. Если вы в настоящее время пишете приложение Electron с использованием той же стратегии _и_ используют размер, который вам не немедленно требуется, примените ту же стратегию и отложите загрузку более чем на подходящее время.

### Почему?

Загрузка модулей является удивительно дорогой операцией, особенно в Windows. Когда ваше приложение запускается, оно не должно заставлять пользователей ждать тех операций, которые в настоящее время не нужны.

This might seem obvious, but many applications tend to do a large amount of work immediately after the app has launched - like checking for updates, downloading content used in a later flow, or performing heavy disk I/O operations.

Давайте рассмотрим код Visual Studio в качестве примера. При открытии файла немедленно отобразит файл без подсветки кода, приоритезация способности взаимодействовать с текстом. Как только он выполнит эту работу, он перейдет к подсветке кода.

### Как?

Рассмотрим пример и предположим, что ваше приложение обрабатывает файлы в фиктивном `.foo` формате. Для этого он полагается на одинаково вымышленный `модуль foo-parser`. При традиционной разработке Node.js вы можете написать код, который с трудом загружает зависимости:

```js
const fs = require('fs')
const fooParser = require('foo-parser')

class Parser {
  constructor () {
    this.files = fs.readdirSync('.')
  -

  получаютParsedFiles ()
    возврат fooParser.parse (this.files)



const parser - новый Parser ()

 { parser }модуль.
```

В приведенном выше примере мы выполняем большую работу, которая выполняется как только после загрузки файла. Нужно ли нам сразу разобрать файлы? Можем ли мы сделать это позже, когда вызывается `getParsedFiles()`?

```js
// "fs" скорее всего уже загружается, так что вызов `require()` дешево
const fs = require('fs')

класса Parser {
  async getFiles () {
    // Коснитесь диска как только вызван `getFiles`, не ранее.
    // Также убедитесь, что мы не блокируем другие операции с помощью
    // асинхронной версии.
    this.files = this.files || await fs.readdir('.')

    return this.files
  }

  async getParsedFiles () {
    // Our fictitious foo-parser is a big and expensive module to load, so
    // defer that work until we actually need to parse files.
    // Поскольку `require()` поставляется с кэшем модуля, `require()` call
    // будет дорого только один раз - последующие вызовы `getParsedFiles()`
    // будут быстрее.
    const fooParser = require('foo-parser')
    const files = await this.getFiles()

    return fooParser.parse(files)
  }
}

// This operation is now a lot cheaper than in our previous example
const parser = new Parser()

module.exports = { parser }
```

Короче говоря, выделяйте ресурсы "только вовремя" вместо того, чтобы распределять их все , когда ваше приложение запускается.

## 3) Блокировка основного процесса

Основной процесс Electron (иногда называемый "процесс браузера") является особенным: родительский процесс для всех других процессов вашего приложения и основной процесс взаимодействия с операционной системой. It handles windows, interactions, and the communication between various components inside your app. It also houses the UI thread.

Ни при каких обстоятельствах вы не должны блокировать этот процесс и пользовательскую тему длинными операциями. Блокировка пользовательского интерфейса означает, что все ваше приложение заморозится до тех пор, пока главный процесс не будет готов продолжить обработку.

### Почему?

The main process and its UI thread are essentially the control tower for major operations inside your app. When the operating system tells your app about a mouse click, it'll go through the main process before it reaches your window. Если в окне отображается гладкая бабочка, он должен поговорить с процессом GPU о нем – еще раз пройдя через основной процесс.

Electron и Chromium осторожно помещают операции ввода-вывода и CPU-привязки к процессору в новые потоки, чтобы избежать блокировки пользовательского интерфейса. Вы должны сделать то же самое.

### Как?

Мощная многопроцессная архитектура Electron готова помочь с долгосрочными задачами, но также включает небольшое количество ловушек производительности.

1) For long running CPU-heavy tasks, make use of [worker threads][worker-threads], consider moving them to the BrowserWindow, or (as a last resort) spawn a dedicated process.

2) Avoid using the synchronous IPC and the `remote` module as much as possible. Хотя есть законные варианты использования, слишком легко случайно заблокировать пользовательский интерфейс, используя удаленный</code> модуль `.</p>

<p spaces-before="0">3) Не использовать блокирование операций ввода-вывода в основном процессе. In short, whenever
core Node.js modules (like <code>fs` or `child_process`) offer a synchronous or an asynchronous version, you should prefer the asynchronous and non-blocking variant.

## 4) Блокирование процесса рендерера

С Electron корабли с текущей версией Chrome, вы можете использовать последние и наибольшие возможности, которые веб-платформа предлагает отложить или выгрузить тяжелые операции таким образом, чтобы ваше приложение было легко и быстро.

### Почему?

Вероятно, у вашего приложения есть много JavaScript, чтобы запустить процесс визуализации. трюк должен выполнять операции как можно быстрее, не отнимая ресурсов, необходимых для плавного прокрутки, ответьте на ввод пользователя или на анимацию в 60fps.

Оркестрирование потока операций в коде вашего устройства особенно полезно, если пользователи жалуются на ваше приложение иногда "заикающийся".

### Как?

Вообще говоря, все советы по созданию эффективных веб-приложений для современных браузеров применимы и к устройствам работы Electron. Две основные инструменты , находящиеся в вашем распоряжении в настоящее время `requestIdleCallback()` для небольших операций и `Web Workers` для длительных операций.

*`requestIdleCallback()`* позволяет разработчикам выставить функцию в очередь на выполнение сразу же после входа процесса в период простоя. Это позволяет выполнять низкоприоритетную или фоновую работу без ущерба для пользовательского опыта. For more information about how to use it, [check out its documentation on MDN][request-idle-callback].

*Web Workers* является мощным инструментом для запуска кода в отдельном потоке. There are some caveats to consider – consult Electron's [multithreading documentation][multithreading] and the [MDN documentation for Web Workers][web-workers]. Они являются идеальным решением для любой операции, требующей большой мощности процессора в течение длительного периода времени.

## 5) Ненужные polyfills

Одним из преимуществ Electron является то, что вы точно знаете, какой движок будет парсить ваш JavaScript, HTML и CSS. Если вы повторно используете код, который был написан для веб в целом, убедитесь, что вы не должны полифилить функции, включенные в Electron.

### Почему?

При создании веб-приложения для сегодняшнего Интернета старейшая среда диктовать, какие особенности вы можете и не можете использовать. Несмотря на то, что Electron поддерживает хорошо работающих CSS-фильтров и анимации, старый браузер может не работать. Где вы могли бы использовать WebGL, ваши разработчики могли выбрать больше решения для поддержки старых телефонов.

Когда дело доходит до JavaScript, возможно, у вас есть такие библиотеки, как jQuery для DOM селекторов или полифилдов, как `regenerator-runtime` для поддержки `async/await`.

Редко для полизаполнения на основе JavaScript, чем эквивалент родной функции Electron. Не замедляйте работу приложения Electron, отправив на свою собственную версию стандартной веб-платформы.

### Как?

Действует при том предположении, что многополы в текущих версиях Electron не нужны. Если у вас есть сомнения, проверьте [caniuse. om](https://caniuse.com/) и проверьте, поддерживает ли [версия Chromium, используемая в вашей Electron версии](../api/process.md#processversionschrome-readonly) функцию, которую вы хотите.

Кроме того, внимательно изучите используемые вами библиотеки. Действительно ли они необходимы? Например, `jQuery`, был настолько успешным, что многие его функции теперь являются частью [стандартного набора возможностей JavaScript][jquery-need].

Если вы используете транспонлер/компилятор, например TypeScript, изучите его конфигурацию и убедитесь, что вы ориентируетесь на последнюю версию ECMAScript, поддерживаемую Electron.

## 6) Не требуется или блокирует сетевые запросы

Избегайте получения редких ресурсов из интернета, если они могут легко быть объединены с вашим приложением.

### Почему?

Многие пользователи Electron начинаются с полностью основанного на Интернете приложения, которые превращаются в настольное приложение. Будучи веб-разработчиками, мы используем для загрузки ресурсов из различных сетей доставки контента. Теперь, когда вы отправляете подходящее настольное приложение, попытаться «вырезать корд» там, где это возможно, и не позволять пользователям ждать, пока ресурсы никогда не меняются и легко могут быть включены в ваше приложение.

Типичным примером является Google шрифты. Многие разработчики используют впечатляющую коллекцию бесплатных шрифтов Google, которая поставляется с сетью доставки контента . Шаг прост: Включите несколько строк CSS и Google позаботится об остальном.

При создании приложения Electron пользователи лучше обслуживаются при загрузке шрифтов и их включении в комплект вашего приложения.

### Как?

В идеальном мире приложению не понадобится сеть для работы на всех. Чтобы получить доступ к ним, вы должны понять, какие ресурсы ваше приложение загружает \- и насколько велики эти ресурсы.

Для этого откройте инструменты разработчика. Navigate to the `Network` tab and check the `Disable cache` option. Затем перезагрузите устройство. Если ваше приложение не запрещает такие перезагрузки, обычно можно запустить перезагрузку, нажимая `Cmd + R` или `Ctrl + R` с фокусом на инструменты разработчика.

Инструменты теперь будут аккуратно записывать все сетевые запросы. Первым шагом проверит все загружаемые ресурсы, сосредоточив внимание на больших файлах . Любые из них изображения, шрифты или медиафайлы, которые не изменяются и могут быть включены в ваш комплект? Если да, то включить их.

В качестве следующего шага включите `сетевой тротлинг`. Найдите выпадающий список, который читает `Онлайн` и выберите более медленную скорость, такую как `Быстрое 3G`. Перезагрузите ваш рендерер и проверьте, есть ли какие-либо ресурсы, которые ваше приложение неоправданно ожидает. Во многих случаях приложение ждет завершения сетевого запроса , несмотря на то, что он фактически не нуждается в соответствующем ресурсе.

Подсказка: загрузка ресурсов из интернета, которые вы можете изменить , без доставки обновлений приложения является мощной стратегией. For advanced control over how resources are being loaded, consider investing in [Service Workers][service-workers].

## 7) Набор вашего кода

Как уже отмечалось в "[Загрузка и запуск кода слишком скоро](#2-loading-and-running-code-too-soon)", вызов `require()` является дорогостоящей операцией. Если вы можете это сделать, добавьте код вашего приложения в один файл.

### Почему?

Современная разработка JavaScript обычно включает в себя много файлов и модулей. В то время как отлично подходит для разработки с Electron, мы настоятельно рекомендуем объединить весь ваш код в один файл, чтобы убедиться, что накладные включенные в вызов `require()` оплачиваются только после загрузки приложения.

### Как?

Там есть много пакетов JavaScript, и мы знаем лучше, чем угрожать сообществу, рекомендуя один инструмент по отношению к другому. Тем не менее, мы рекомендуем вам использовать комплект, способный работать с уникальной средой , которая должна работать с обоими узлами. и окружения браузеров.

As of writing this article, the popular choices include [Webpack][webpack], [Parcel][parcel], and [rollup.js][rollup].

[4]: ../images/performance-cpu-prof.png
[5]: ../images/performance-heap-prof.png

[security]: ./security.md
[chrome-devtools-tutorial]: https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/
[worker-threads]: https://nodejs.org/api/worker_threads.html
[web-workers]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers
[request-idle-callback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
[multithreading]: ./multithreading.md
[jquery-need]: http://youmightnotneedjquery.com/
[service-workers]: https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API
[webpack]: https://webpack.js.org/
[parcel]: https://parceljs.org/
[rollup]: https://rollupjs.org/
[vscode-first-second]: https://www.youtube.com/watch?v=r0OeHRUCCb4
