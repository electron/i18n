# MessagePorts в электроне

[`MessagePort`][]веб-функция, которая позволяет передачи сообщений между различных контекстах. Это как в `window.postMessage`, но по разным каналам. Цель этого документа состоит в том, чтобы описать, как Electron расширяет модель обмена сообщениями Channel , и привести несколько примеров того, как вы можете использовать MessagePorts вашем приложении.

Вот очень краткий пример того, что такое MessagePort и как он работает:

```js
Рендерер.js /////////
/ Связанная пара портов сообщений
// называется каналом.
const канал - новый канал сообщения ()

// Единственное различие между port1 и port2 заключается в том, как вы их используете. Сообщения
// отправлены в port1 будут получены port2 и наоборот.
const port1 - channel.port1
const port2 - channel.port2

// Это нормально, чтобы отправить сообщение на канале, прежде чем другой конец зарегистрировал
// слушатель. Сообщения будут стоять в очереди до регистрации слушателя.
port2.postMessage ({ answer: 42 })

// Здесь мы отправляем другой конец канала, port1, в основной процесс. Это также
// также можно отправить MessagePorts на другие кадры, или веб-работников и т.д.
ipcRenderer.postMessage ('порт', null, [port1])
```

```js
основной.js /////////
/
ipcMain.on ('port', (событие) -> -
  // Когда мы получаем MessagePort в основном процессе, он становится
  // MessagePortMain.
  const port - event.ports[0]

  // MessagePortMain использует API событий в стиле узла.js, а не API
  // события в веб-стиле. Так .on ('сообщение', ...) вместо .onmessage ...
  port.on ('message', (событие) -> -
    // данные { answer: 42 }
    const data - event.data
  )/

  // Сообщения очередей MessagePortMain до тех пор, пока не будет назван метод .start().
  port.start ()
)
```

Данный [обмена сообщениями][] является отличным способом узнать больше о том, работает MessagePorts.

## MessagePorts в основном процессе

В рендере класс `MessagePort` себя точно так же, как и в Интернете. Основной процесс не веб-страницы, хотя и не имеет blink интеграции, и поэтому он не имеет `MessagePort` или `MessageChannel` классов. Для того, обрабатывать и взаимодействовать с MessagePorts в основном процессе, Electron добавляет два новых классах: [`MessagePortMain`][] и [`MessageChannelMain`][]. Они ведут аналогично аналогичным классам в рендере.

`MessagePort` объекты могут быть созданы в процессе рендерера или основного , и передаются туда и обратно с помощью [`ipcRenderer.postMessage`][] и [`WebContents.postMessage`][] методов. Обратите внимание, что обычные методы IPC, `send` и `invoke` не могут быть использованы для передачи `MessagePort`s, `postMessage` методы могут передавать `MessagePort`s.

Передавая `MessagePort`через основной процесс, вы можете подключить две страницы, которые в противном случае не могли бы общаться (например, из-за ограничений происхождения).

## Расширение: `close` событие

Electron добавляет одну функцию `MessagePort` , которая не присутствует в Интернете, в чтобы сделать MessagePorts более полезным. Это событие `close` , которое , когда другой конец канала закрыт. Порты также могут быть закрыты путем сбора мусора.

В рендере вы можете прослушать событие `close` , назначив его `port.onclose` или позвонив `port.addEventListener('close', ...)`. В основном , вы можете прослушать событие `close` , позвонив `port.on ('close',
...)`.

## Примеры использования случаев

### Рабочий процесс

В этом примере в приложении есть рабочий процесс, реализованный как скрытое окно. Вы хотите, чтобы страница приложения могла напрямую общаться с , без накладных расходов на ретрансляцию через основной процесс.

```js
основной.js ///////
/приложение, ipcMain, MessageChannelMain - требуют ('электрон')

app.whenReady().,тогда (async ()> -
  // Рабочий процесс является скрытым BrowserWindow, так что он будет иметь доступ
  // к полному контексту Blink (включая, например. <canvas>, аудио, принести () и т.д.)
  const worker - новый BrowserWindow (шоу
    : false,
    webPreferences: { nodeIntegration: true }
  )
  ждут worker.loadFile ('worker.html')

  // Основное окно отправит работу в рабочий процесс и получит результаты
  // через MessagePort.
  const mainWindow - новый BrowserWindow (no
    webPreferences: { nodeIntegration: true }
  )
  mainWindow.loadFile ('app.html')

  // Мы не можем использовать ipcMain.handle () здесь, потому что ответ должен передать
  // MessagePort.
  ipcMain.on ('request-worker-channel', (событие) -> -
    // По соображениям безопасности давайте убедитесь, что только кадры, которые мы ожидаем, могут
    // получить доступ к работнику.
    если (event.senderFrame - mainWindow.webContents.mainFrame) -
      // Создайте новый канал ...
      const { port1, port2 } - новый MessageChannelMain ()
      // ... отправить один конец работника ...
      worker.webContents.postMessage («новый клиент», null, [port1])
      // ... а другой конец к главному окну.
      event.senderFrame.postMessage ('provide-worker-channel', null, [port2])
      // Теперь основное окно и работник могут общаться друг с другом
      // не переходя через основной процесс!
    (
  )
)
```

```html<!-- работник.html ------------------------------------------------------------><script>
const { ipcRenderer } требует ('электрон')

doWork (вход) -
  // Что-то cpu-интенсивное.
  возвратный вход No 2


// Мы можем получить несколько клиентов, например, если есть несколько окон,
// или если основное окно перезагружается.
ipcRenderer.on ('new-client', (событие) -> -
  const - порт - event.ports
  port.onmessage (событие) -> -
    // Данные о событии могут быть любым серийным объектом (и событие может даже
    // нести с собой другие MessagePorts!)
    const результат - doWork (event.data)
    port.postMessage (результат)

)
</script>
```

```html<!-- приложение.html ---------------------------------------------------------------><script>
const { ipcRenderer } и требуют ('электрон')

// Мы просим, чтобы основной процесс посылает нам канал, который мы можем использовать для
// общаться с работником.
ipcRenderer.send ('request-worker-channel')

ipcRenderer.once ('provide-worker-channel', (событие) -> -
  // Как только мы получим ответ, мы можем взять порт...
  const - порт - event.ports
  // ... зарегистрировать обработчик для получения результатов ...
  port.onmessage (событие) -> -
    консоли.log ("полученный результат:', event.data)
  -
  // ... и начать посылать его работу!
  port.postMessage (21)
)
</script>
```

### Потоки ответов

Встроенные методы IPC Electron поддерживают только два режима: пожар и (например. `send`), или запрос-ответ (например. `invoke`). Используя MessageChannels, можете реализовать "поток ответов", где один запрос отвечает потоком данных.

```js
Рендерер.js ///////

/обратный вызов)
  // Каналы сообщений легкие - это дешево, чтобы создать новый для каждого
  // запрос.
  const { port1, port2 } и новый MessageChannel ()

  // Мы отправляем один конец порта в основной процесс ...
  ipcRenderer.postMessage (
    "дай мне поток",
    { element, count: 10 },
    [port2]
  )

  // ... и мы держимся за другой конец. Основной процесс будет отправлять сообщения
  // до конца порта, и закрыть его, когда он будет закончен.
  port1.onmessage (событие) -> -
    обратный вызов (event.data)

  port1.onclose () -> -
    консоли.log ('поток закончился')
  -
-

makeStreamingRequest(42, (данные) ->
  консоли.log (данные ответа:', event.data)
q)
// Мы увидим "полученные данные ответа: 42" 10 раз.
```

```js
основной.js //////////

/(событие, msg) ->
  // Ренидер прислал нам MessagePort, что он хочет, чтобы мы отправили наш
  // ответ.
  const [replyPort] event.ports

  // Здесь мы отправляем сообщения синхронно, но мы могли бы так же легко хранить
  // порт где-то и отправлять сообщения асинхронно.
  ибо (позвольте мне 0; i < msg.count; i') -
    replyPort.postMessage (msg.element)
  -

  // Мы закроем порт, когда мы будем готовы указать другому концу, что мы
  // не будем отправлять больше сообщений. Это не является строго необходимым - если мы
  // явно не закрыть порт, он в конечном итоге будет мусор
  // собранные, которые также вызовет "закрыть" событие в рендере.
  replyPort.close ()
)
```

### Общение непосредственно между основным процессом и главным миром изолированной от контекста страницы

Когда [изоляция][] контекста, сообщения IPC от основного процесса до рендерера доставляются в изолированный мир, а не в мире. Иногда вы хотите доставить сообщения в главный мир напрямую, без необходимости шаг через изолированный мир.

```js
основной.js /////////
const { BrowserWindow, app, MessageChannelMain } - требуют ('электрон')
const path - требуют ('path')

app.whenReady ().,тогда (async () -> -
  // Создайте BrowserWindow с включенным контекстомIsolation.
  const bw - новый BrowserWindow (является
    webPreferences: -
      contextIsolation: true,
      : path.join (__dirname, 'preload.js')
    -
  )
  bw.loadURL ('индекс.html')

  // Мы направим один конец этого канала в главный мир страницы
  // контекст.
  const { port1, port2 } - новый MessageChannelMain ()

  // Это нормально, чтобы отправить сообщение на канале, прежде чем другой
  // зарегистрированный слушатель. Сообщения будут стоять в очереди до тех пор, пока слушатель не
  // зарегистрирован.
  port2.postMessage ({ test: 21 })

  // Мы также можем получать сообщения из основного мира рендерера.
  port2.on ('сообщение', (событие) -> - консоль
    .log ('от рендерера основного мира:', event.data)
  q)
  port2.start()

  // Скрипт предварительной загрузки получит это сообщение IPC и перенесите порт
  // в основной мир.
  bw.webContents.postMessage ('main-world-port', null, [port1])
)
```

```js
предварительная загрузка.js /////////////////////////
const { ipcRenderer } - требуют ('электрон')

// Нам нужно подождать, пока главный мир не будет готов получить сообщение до
// отправки порта. Мы создаем это обещание в предварительной загрузке, так что это
// зарегистрировать onload слушателя до загрузки событие уволено.
const окноЗагруженное - новое обещание (разрешение -> -
  window.onload - разрешение
)

ipcRenderer.on('main-world-port', async (событие) -> -
  ждем окнаLoaded
  // Мы используем регулярно window.postMessage для переноса порта из изолированного
  // мир в главный мир.
  window.postMessage ('main-world-port', '', event.ports)
)
```

```html<!--.html -------------------------------------------------------------><script>
window.onmessage (событие) -> -
  // event.source - окно означает, что сообщение исходит от предустановки
  // скрипта, в отличие от <iframe> или другого источника.
  если (событие.источник - окно && event.data - "основной мир-порт") -
    const - порт - event.ports
    // Как только у нас есть порт, мы можем напрямую общаться с основным
    // процессом.
    port.onmessage (событие) -> - консоль
      .log ('от основного процесса:', event.data)
      port.postMessage (event.data No 2)



</script>
```

[изоляция]: context-isolation.md
[`ipcRenderer.postMessage`]: ../api/ipc-renderer.md#ipcrendererpostmessagechannel-message-transfer
[`WebContents.postMessage`]: ../api/web-contents.md#contentspostmessagechannel-message-transfer
[`MessagePortMain`]: ../api/message-port-main.md
[`MessageChannelMain`]: ../api/message-channel-main.md
[`MessagePort`]: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort
[обмена сообщениями]: https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API
