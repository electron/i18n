# Глоссарий

Данная страница посвящена терминам, которые обычно используются при разработке на Electron.

### ASAR

ASAR это Atom Shell Archive Format. [Asar](https://github.com/electron/asar) это простой архив `tar`-подобного формата, который объединяет файлы в один файл. Electron может читать файлы в архиве без распаковки оного.

Формат ASAR был создан для повышения производительности в среде Windows

### Brightray

Brightray [была](https://github.com/electron-archive/brightray) статической библиотекой, созданной для того чтобы [libchromiumcontent](#libchromiumcontent) было проще использовать в приложениях. Сейчас она уже является устаревшей и была объединена с кодовой базой Electron.

### CRT

Библиотека C Run-time (CRT) является частью стандартной библиотеки C++, которая включает стандартную библиотеку ISO C99. Библиотеки Visual C++, которые реализуют CRT, поддерживают развитие машинного кода и смешанного собственного и управляемого кода и чисто управляемого кода для разработки .NET.

### DMG

Apple Disk Image (DMG) это пакетный формат, который используется в macOS. DMG файлы обычно используются для распространения "установщиков" приложения. [electron-builder](https://github.com/electron-userland/electron-builder) поддерживает `dmg` как целевой объект компиляции.

### IME

Input Method Editor. Эта программа позволяет пользователям вводить символы, которые отсутствуют на клавиатуре. Например, это позволяет пользователям Латинской клавиатуры вводить Китайские, Японские, Корейские и Хинди символы.

### IDL

Язык описания интерфейса. Записывайте сигнатуры функций и типы данных в формате, который может использоваться для создания интерфейсов в Java, C ++, JavaScript и т. д.

### IPC

IPC стенды для взаимодействия между процессами. Electron использует IPC для отправки сериализованных JSON сообщения, между [main(главный)](#main-process) и [renderer(отображения)](#renderer-process) процессами.

### libchromiumcontent

Общая библиотека, которая включает в себя [модуль Chromium Content](https://www.chromium.org/developers/content-module) и все его зависимости. (Например, Blink, [V8](#v8) и т.д.). Также именуется, как "libcc".

- [github.com/electron/libchromiumcontent](https://github.com/electron/libchromiumcontent)

### главный (main) процесс

Главный процесс, обычно файл с именем `main.js`, является точкой входа для каждого приложения Electron. Он контролирует жизнь приложения, от его открытия до закрытия. Также управляет нативными элементами, такими как Menu, Menu Bar, Dock, Tray, и др. Главный процесс отвечает за создание каждого нового процесса отображения(renderer) в приложение. Полностью встроено Node API.

Каждый файл главного процесса приложения указывается в свойство `main` в `package.json`. Так `electron .` узнает какой файл выполнять при запуске.

В хроме этот процесс называется «процесс браузера». Он переименовывается в Electron, чтобы избежать путаницы с процессами отображения.

См. также: [процесс](#process), [процесс отображения(renderer)](#renderer-process)

### MAS

Акроним к Apple's Mac App Store. Для более подробных сведений см. [Mac App Store Submission Guide](tutorial/mac-app-store-submission-guide.md).

### Mojo

An IPC system for communicating intra- or inter-process, and that's important because Chrome is keen on being able to split its work into separate processes or not, depending on memory pressures etc.

Смотри https://chromium.googlesource.com/chromium/src/+/master/mojo/README.md

### собственные модули

Собственные модули (также называемые [дополнениями](https://nodejs.org/api/addons.html) в Node.js) это модули написанные на C или C++, которые могут быть загружены в Node.js или Electron используя функцию require(), и используются так, как если бы они были обычным модулем Node.js. Они используются главным образом для предоставления интерфейса между скриптов JavaScript, выполняющийся в Node.js и C/C++ библиотеках.

Собственные модули Node поддерживаются в Electron, но учитывая, что Electron предпочитает использовать разные версии V8 для Node, установленного на Вашем компьютере, вы должны вручную указать расположение заголовков Electron'а, когда собираете собственные модули.

См. также [Использование собственных модулей Node](tutorial/using-native-node-modules.md).

### NSIS

Nullsoft Scriptable Install System это управляемое скриптом средство установки для Microsoft Windows. Оно выпускается под сочетанием различных лицензий на свободное программное обеспечение и является широко используемой альтернативой коммерческим проприетарным продуктам, таким как например InstallShield. [electron-builder](https://github.com/electron-userland/electron-builder) поддерживает NSIS как целевой объект компиляции.

### OSR

OSR (закадровый рендеринг) может использоваться для загрузки тяжелых страниц в фоновом режиме и затем отобразит её после (это будет намного быстрее). Это позволяет Вам рендерить страницу без отображения на экране.

### процесс

Процесс является экземпляром компьютерной программы, который выполняется. Electron приложения используют [главный(main)](#main-process) процесс и один или более процессы [отображения(renderer)](#renderer-process), на самом деле работает несколько программ одновременно.

В Node.js и Electron, каждый запущенный процесс имеет объект `process`. Этот объект является глобальным, предоставляющий информацию о текущем процессе и контроль над ним. Он всегда доступен глобально в приложение без использования require().

См. также: [основной(main) процесс](#main-process), [процесс отображения(renderer)](#renderer-process)

### процесс отображения (renderer)

Процесс отображения является окном браузера в Вашем приложении. В отличие от основного процесса, их может быть несколько и каждый запускается в отдельном процессе. Они также могут быть скрыты.

В нормальных браузерах, веб-страницы обычно выполняются в изолированной среде и им не разрешается доступ к нативным ресурсам. Пользователи Electron'а, однако, имеют право использовать API Node.js на веб-страницах, позволяя взаимодействовать на нижнем уровне операционной системы.

См. также: [процесс](#process), [основной(main) процесс](#main-process)

### Squirrel

Squirrel является фреймворком с открытым исходным кодом, который позволяет Electron приложениям автоматически обновляться, когда выпустится новая версия. См. [autoUpdated](api/auto-updater.md) API для информации о начале работы с Squirrel.

### пользовательское пространство

Этот термин возник в сообществе Unix, где "userland" или "userspace" относится к программам, которые выполняются за пределами ядра операционной системы. Этот термин был популяризирован в сообществах Node и npm, чтобы различать функции доступные в "ядре Node" по сравнению с пакетами опубликованными в реестре npm гораздо более "пользовательским" сообществом.

Как и Node, Electron сфокусирован на наличии небольшого набора API функций, которые обеспечивают весь необходимый базис для разработки кросс-платформенных настольных приложений. Такая философия позволяет Electron оставаться гибким инструментом, будучи не предписывая того как им пользоваться. Пользовательское пространство позволяет создавать и совместно использовать инструменты, которые обеспечивают дополнительный функционал поверх того, который доступен в ядре.

### V8

V8 - JavaScript движок с открытым исходным кодом компании Google. Он написан на C++ и используется в Google Chrome. V8 может быть запущен автономно или может быть встроен в любое C++ приложение.

Electron компилирует V8 как часть Chromium а затем указывает Node использовать этот V8 при сборке.

Версионирование V8 соответствует номерам версий в Google Chrome. Chrome 59 версии включает в себя V8 5.9, Chrome 58- V8 5.8 версии и т.д.

- [developers.google.com/v8](https://developers.google.com/v8)
- [nodejs.org/api/v8.html](https://nodejs.org/api/v8.html)
- [docs/development/v8-development.md](development/v8-development.md)

### webview

Теги `webview` используются для того, чтобы встроить сторонние ресурсы (например внешние веб-страницы) в ваше Electron приложение. Они похожи на `iframe`, но отличается тем, что каждый webview запускается в отдельном процессе. Оно не имеет тех же разрешений, так как ваша веб страница и все взаимодействие между вашим приложением и встроенным контентом будут асинхронными. Это позволяет защитить ваше приложение от встраиваемого содержимого.