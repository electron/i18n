# Опция `sandbox`

> Создайте окно браузера с помощью песочницы renderer. С помощью опции рендер должен общаться через IPC с основным процессом, чтобы получить доступ к API узла.

Одна из основных особенностей безопасности Chromium заключается в том, что весь рендеринг/JavaScript-код выполняется внутри песочницы. В этой песочнице используются специфичные для ОС функции, для гарантии того, что эксплойты в процессе рендеринга не смогли повредить систему.

Другими словами, при включенной песочнице рендеры могут вносить изменения в систему только путем делегирования задач основному процессу через IPC. [Здесь](https://www.chromium.org/developers/design-documents/sandbox) больше информации о песочнице.

Поскольку основной особенностью Electron является возможность запуска Node.js в процессе рендеринга (что облегчает разработку настольных приложений с помощью веб-технологий), в Electron песочница отключена. Это связано с тем, что большинству API Node.js требуется доступ к системе. Например, `require()` невозможен без разрешений файловой системы, которые недоступны в песочнице.

Обычно это не проблема для настольных приложений, так как код всегда является доверенным, но это делает Electron менее безопасным, чем Chromium для отображения ненадежного веб-содержимого. Для приложений, требующих большей безопасности, флаг `sandbox` вынудит Electron создать классический рендерер Chromium, совместимый с песочницей.

Изолированный рендер не имеет запущенной среды Node.js и не предоставляет доступ к API-интерфейсу JavaScript Node.js для клиентского кода. Единственным исключением является сценарий предварительной загрузки, который имеет доступ к подмножеству API рендерера Electron.

Другое отличие заключается в том, что рендереры, работающие в песочнице, не изменяют стандартные API JavaScript. Следовательно, некоторые API, такие как `window.open` будут работать так же, как в Chromium (то есть они не возвращают [`BrowserWindowProxy`](browser-window-proxy.md)).

## Пример

Чтобы создать окно в песочнице, установите `sandbox: true` в `webPreferences`:

```js
пусть выиграть
app.whenReady (
.com
  {
      sandbox: true
    }
  
    
  > )...
```

В приведенном выше коде у созданного [`BrowserWindow`](browser-window.md) отключен Node.js и он может общаться только через IPC. Использование этой опции не позволяет Electron создавать в рендерере среду выполнения Node.js. Кроме того, в этом новом `window.open` следует за родным поведением (по умолчанию Electron создает [`BrowserWindow`](browser-window.md) и возвращает прокси к этому через `window.open`).

[`app.enableSandbox`](app.md#appenablesandbox) может использоваться для принудительной установки `sandbox: true` для всех экземпляров `BrowserWindow`.

```js
пусть выиграть
app.enableSandbox()
app.whenReady ().,после этого (()) -> -
  // нет необходимости передавать "песочницу: правда", так как "app.enableSandbox()" был вызван.
  выиграть новый BrowserWindow ()
  win.loadURL ('http://google.com')
)
```

## Предварительная загрузка

Приложение может настроить настройки для песочницы рендеров с помощью скрипта предварительной загрузки. Вот пример:

```js
пусть выиграть
app.whenReady ().., то (()>
  выиграть - новый BrowserWindow (я
    webPreferences:
      песочнице: правда,
      : path.join (app.getAppPath.), 'preload.js')
    и
  )
  win.loadURL ('http://google.com')
)
```

и preload.js:

```js
// Этот файл загружается каждый раз в контексте javascript. Он запускается в 
// приватной области, которая может получить доступ к подмножеству API рендерера Electron. Без
// ContextIsolation включен, можно случайно утечки привилегированных
// глобальных, как ipcRenderer в веб-контента.
const { ipcRenderer } и требуют ('электрон')

const defaultWindowOpen - window.open

window.open - функция customWindowOpen (url, ... args) -
  ipcRenderer.send ('report-window-open', location.origin, url, args)
  возврат по умолчаниюWindowOpen (url-адрес '?from_electron'1', ... аргс)
.
```

Важные вещи, на которые следует обратить внимание в скрипте предварительной загрузки:

- Несмотря на то, что в песочнице не запущен Node.js, он все равно имеет доступ к ограниченной node-подобной среде: `Buffer`, `process`, `setImmediate`, `clearImmediate` и `require` доступны.
- Скрипт для предварительной загрузки должен содержаться в одном скрипте, но может иметь сложный код для предварительной загрузки, состоящий из нескольких модулей, используя такие инструменты, как webpack или browserify. Ниже приведен пример использования browserify.

Чтобы создать пакет browserify пакета и использовать его в качестве скрипта предварительной загрузки, можно сделать что-то вроде этого:

```sh
  browserify preload/index.js \
    -x electron \
    --insert-global-vars=__filename,__dirname -o preload.js
```

Флаг `-x` следует использовать с любым необходимым модулем, который уже задействован в области предварительной загрузки, и сообщает browserify использовать вложенную для него функцию `require`. `--insert-global-vars` будет гарантировать, что `process`, `Buffer` и `setImmediate` также взяты из прилагаемой области видимости (обычно browserify вводит код для них).

В настоящее время функция `require`, представленная в области предварительной загрузки, раскрывает следующие модули:

- `electron`
  - `crashReporter`
  - `desktopCapturer`
  - `ipcRenderer`
  - `nativeImage`
  - `webFrame`
- `events`
- `timers`
- `url`

Больше может быть добавлено по мере необходимости, чтобы разоблачить больше api Electron в песочнице.

## Рендеринг ненадежного контента

Рендеринг ненадежного контента в Electron по-прежнему несколько неизведанной территории, хотя некоторые приложения находят успех (например, Beaker Browser). Наша цель состоит в том, чтобы как можно ближе к Chrome, как мы можем с точки зрения безопасности песочнице содержание, но в конечном счете, мы всегда будем позади из-за нескольких фундаментальных вопросов:

1. У нас нет специальных ресурсов или опыта, которые Chromium должен применять к безопасности своей продукции. Мы делаем все возможное, чтобы использовать то, что у нас есть, чтобы унаследовать все, что мы можем от Chromium, и быстро реагировать на вопросы безопасности , но Electron не может быть таким же безопасным, как Хром без ресурсов , которые Хром способен посвятить.
2. Некоторые функции безопасности в Chrome (такие как Safe Browsing и Сертификат Прозрачность) требуют централизованного управления и выделенных серверов, оба которые ходят вразрез с целями проекта Electron. Таким образом, мы отключаем эти функции в Electron, за счет связанной безопасности, которую они бы в противном случае принести.
3. Существует только один хром, в то время как Есть много тысяч приложений, построенных Electron, все из которых ведут себя немного по-разному. Учет этих могут дать огромное пространство возможности, и сделать его сложным обеспечить безопасность платформы в необычных случаях использования.
4. Мы не можем нажать обновления безопасности для пользователей напрямую, поэтому мы полагаемся на поставщиков приложений обновить версию Electron, лежащую в основе их приложения для того, чтобы обновления безопасности для достижения пользователей.

Вот некоторые вещи, которые следует рассмотреть, прежде чем рендеринг ненадежного содержимого:

- Скрипт предварительной загрузки может случайно привести к утечке привилегированных API в ненадежный код, если только не включен [`contextIsolation`](../tutorial/security.md#3-enable-context-isolation-for-remote-content).
- Некоторые ошибки в двигателе V8 могут позволить вредоносному коду получить доступ к API с предварительной загрузкой, фактически предоставить полный доступ к системе через `remote` модуль. Поэтому настоятельно рекомендуется отключить [модуль `remote` ](../tutorial/security.md#15-disable-the-remote-module). Если отключение не представляется возможным, следует выборочно [фильтровать `remote` модуль](../tutorial/security.md#16-filter-the-remote-module).
- В то время как мы делаем все возможное, чтобы backport Chromium безопасности исправления старых версий Electron, мы не делаем гарантию того, что каждое исправление будет backported. Ваш лучший шанс в безопасности, чтобы быть на последней стабильной версии Electron.
