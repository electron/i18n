# app

> Контролируйте жизненный цикл Вашего приложения.

Процесс: [Основной](../glossary.md#main-process)

Этот пример показывает, как закрыть приложение, когда последнее окно будет закрыто:

```javascript
const { app } = require('electron')
app.on('window-all-closed', () => {
  app.quit()
})
```

## События

Объект `app` имеет следующие события:

### Событие: 'will-finish-launching'

Происходит, когда приложение заканчивает основной запуск. На Windows и Linux событие `will-finish-launching` подобно событию `ready`; на macOS это событие представляет собой уведомление `applicationWillFinishLaunching` объекта `NSApplication`. Обычно настраивают слушателей для `open-file` и `open-url` событий, и запускают репортер сбоев и автоматическое обновление.

В большинстве случаев, Вы должны выполнять всё в обработчике события `ready`.

### Событие: 'ready'

Возвращает:

* `event` Event
* `launchInfo` рекорд<string, any> | [УведомлениеОтветить](structures/notification-response.md) _macOS_

Происходит единожды при завершении инициализации Electron. На macOS `launchInfo` хранит `userInfo` `NSUserNotification` или информацию от [`UNNotificationResponse`](structures/notification-response.md) , которая использовалась для открытия приложения , если оно было запущено из Центра уведомлений. Вы также можете вызвать `app.isReady()` для проверки того, что событие уже произошло и `app.whenReady()` чтобы получить Promise, который выполнится, когда Electron будет инициализирован.

### Событие: 'window-all-closed'

Происходит при закрытии всех окон.

Если Вы не подпишитесь на это событие, и все окна будут закрыты, поведением по умолчанию является выход из приложения; Однако, если Вы подпишитесь, то Вы определяете, будет ли приложение закрыто или нет. Если пользователь нажал `Cmd + Q` или разработчик вызвал `app.quit()`, Electron сначала попытается закрыть все окна, а затем происходит событие `will-quit`, и в этом случае событие `window-all-closed` не будет происходить.

### Событие: 'before-quit'

Возвращает:

* `event` Event

Происходит до того, как приложение начнет закрывать свои окна. Вызов `event.preventDefault()` предотвратит поведение по умолчанию, которое приводит к прекращению работы приложения.

**Примечание:** Если выход приложения был инициирован `autoUpdater.quitAndInstall()`, тогда `before-quit` происходит *после* того, как происходит событие `close` на всех окнах и закрывает их.

**Примечание:** На Windows это событие не произойдет, если приложение закрылось из-за выключения/перезагрузки системы или выхода пользователя из системы.

### Событие: 'will-quit'

Возвращает:

* `event` Event

Возникает, когда все окна будут закрыты и приложение завершит работу. Вызов `event.preventDefault()` предотвратит поведение по умолчанию, которое приводит к прекращению работы приложения.

Смотрите описание события `window-all-closed` для различий между событиями `will-quit` и `window-all-closed`.

**Примечание:** На Windows это событие не произойдет, если приложение закрылось из-за выключения/перезагрузки системы или выхода пользователя из системы.

### Событие: 'quit'

Возвращает:

* `event` Event
* `exitCode` Integer

Происходит при выходе из приложения.

**Примечание:** На Windows это событие не произойдет, если приложение закрылось из-за выключения/перезагрузки системы или выхода пользователя из системы.

### Событие: 'open-file' _macOS_

Возвращает:

* `event` Event
* `path` String

Происходит, когда пользователь хочет открыть файл. Событие `open-file` обычно происходит, когда приложение уже открыто и ОС хочет переиспользовать приложение, чтобы открыть файл. `open-file` также происходит, когда файл уже находится на Dock панели, но приложение еще не запущено. Убедитесь, что обработчик события `open-file` в самом начале запуска Вашего приложения обрабатывает этот случай (даже прежде, чем происходит событие ` ready`).

Вы должны вызвать `event.preventDefault()`, если хотите обработать это событие.

На Windows Вам необходимо распарсить `process.argv` (в основном процессе), чтобы получить путь к файлу.

### Событие: 'open-url' _macOS_

Возвращает:

* `event` Event
* `url` String

Происходит, когда пользователь хочет открыть URL-адрес из приложения. Файл Вашего приложения `Info.plist` должнен определять схему URL в ключе `CFBundleURLTypes` и установить `NSPrincipalClass` в `AtomApplication`.

Вы должны вызвать `event.preventDefault()`, если хотите обработать это событие.

### Событие: 'activate' _macOS_

Возвращает:

* `event` Event
* `hasVisibleWindows` Boolean

Происходит при активации приложения. Различные действия могут запускать это событие, например, запуск приложения в первый раз, попытка перезапустить приложение, когда оно уже запущено, или клик на иконку приложения на панели dock или панели задач.

### Событие: 'did-become-active' _macOS_

Возвращает:

* `event` Event

Происходит при активации приложения. Отличие от события `activate` в том, что `did-become-active` происходит после каждой активации приложения, а не только при нажатии на иконку на панели задач или перезапуске приложения.

### Событие: 'continue-activity' _macOS_

Возвращает:

* `event` Event
* `type` String - строка идентифицирует активность. Карты для [`NSUserActivity.activityType`][activity-type].
* `userInfo` unknown - содержит специфическое для приложения состояние, сохраненное на другом устройстве.

Происходит во время [Handoff][handoff], когда активность с другого устройства хочет возобновиться. Если Вы хотите обработать это событие, следует вызвать `event.preventDefault()`.

Активность пользователя может быть продолжена только в приложении, которое имеет тот же ID команды разработчика, что и активность исходного приложения, и поддерживает тип активности. Поддерживаемые типы активности, указаны в `Info.plist` приложения под ключом `NSUserActivityTypes`.

### Событие: 'will-continue-activity' _macOS_

Возвращает:

* `event` Event
* `type` String - строка идентифицирует активность. Карты для [`NSUserActivity.activityType`][activity-type].

Происходит во время [Handoff][handoff] до того, как активность с другого устройства хочет возобновиться. Если Вы хотите обработать это событие, следует вызвать `event.preventDefault()`.

### Событие: 'continue-activity' _macOS_

Возвращает:

* `event` Event
* `type` String - строка идентифицирует активность. Карты для [`NSUserActivity.activityType`][activity-type].
* `error` String - cтрока с локализованным описанием ошибки.

Происходит во время [Handoff][handoff], при ошибочном возобновлении активности на различных устройствах.

### Событие: 'activity-was-continued' _macOS_

Возвращает:

* `event` Event
* `type` String - строка идентифицирует активность. Карты для [`NSUserActivity.activityType`][activity-type].
* `userInfo` unknown - содержит специфичное, для приложения, состояние, сохраненное в хранилище по активности.

Происходит во время [Handoff][handoff], после удачного возобновления на другом устройстве.

### Событие: 'update-activity-state' _macOS_

Возвращает:

* `event` Event
* `type` String - строка идентифицирует активность. Карты для [`NSUserActivity.activityType`][activity-type].
* `userInfo` unknown - содержит специфичное, для приложения, состояние, сохраненное в хранилище по активности.

Происходит во время [Handoff][handoff], когда вот-вот возобновится на другом устройстве. Если Вы хотите обновить состояние, которое будет передано, Вам необходимо вызвать `event.preventDefault()` немедленно, собрать новый словарь `userInfo` и вызвать `app.updateCurrentActivity()` своевременно. Иначе, операция завершится ошибкой и будет вызвано `continue-activity-error`.

### Событие: 'new-window-for-tab' _macOS_

Возвращает:

* `event` Event

Возникает при нажатии пользователем кнопки новой вкладки macOS. Кнопка новой вкладки отобразится только если текущий `BrowserWindow` имеет `tabbingIdentifier`

### Событие: 'browser-window-blur'

Возвращает:

* `event` Event
* `window` [BrowserWindow](browser-window.md)

Происходит, когда [browserWindow](browser-window.md) теряет фокус.

### Событие: 'browser-window-focus'

Возвращает:

* `event` Event
* `window` [BrowserWindow](browser-window.md)

Происходит, когда [browserWindow](browser-window.md) получает фокус.

### Событие: 'browser-window-created'

Возвращает:

* `event` Event
* `window` [BrowserWindow](browser-window.md)

Происходит, когда создался новый [browserWindow](browser-window.md).

### Событие: 'web-contents-created'

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)

Происходит, когда создался новый [webContents](web-contents.md).

### Событие: 'certificate-error'

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)
* `url` String
* `error` String - код ошибки
* `certificate` [Certificate](structures/certificate.md)
* `callback` Function
  * `isTrusted` Boolean - учитывать ли сертификат, как надёжный

Происходит, когда не удалось проверить `certificate` для `url`, чтобы доверять сертификату, Вы должны предотвратить поведение по умолчанию с помощью `event.preventDefault()` и вызвать `callback(true)`.

```javascript
const { app } = require('electron')

app.on('certificate-error', (event, webContents, url, error, certificate, callback) => {
  if (url === 'https://github.com') {
    // Сверка логики.
    event.preventDefault()
    callback(true)
  } else {
    callback(false)
  }
})
```

### Событие: 'select-client-certificate'

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)
* `url` URL
* `certificateList` [Certificate[]](structures/certificate.md)
* `callback` Function
  * `certificate` [Certificate](structures/certificate.md) (опционально)

Происходит, когда запрошен сертификат клиента.

`url` соответствует записи навигации, запрашивающей сертификат клиента, а `callback` можно вызвать с записью, отфильтрованной из списка. `event.preventDefault()` предотвращает использование первого сертификата из хранилища.

```javascript
const { app } = require('electron')

app.on('select-client-certificate', (event, webContents, url, list, callback) => {
  event.preventDefault()
  callback(list[0])
})
```

### Событие: 'login'

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)
* `authenticationResponseDetails` Object
  * `url` URL
* `authInfo` Object
  * `isProxy` Boolean
  * `scheme` String
  * `host` String
  * `port` Integer
  * `realm` String
* `callback` Function
  * `username` String (опционально)
  * `password` String (опционально)

Происходит, когда `webContents` выполняет базовую аутентификацию.

Поведение по умолчанию - отмена всех аутентификаций. Чтобы переопределить это, Вы должны предотвратить поведение по умолчанию с помощью `event.preventDefault()` и вызвать `callback(username, password)` с учетными данными.

```javascript
const { app } = require('electron')

app.on('login', (event, webContents, details, authInfo, callback) => {
  event.preventDefault()
  callback('username', 'secret')
})
```

Если ` calllback` вызывается без имени пользователя или пароля, запрос аутентификации будет отменен и ошибка аутентификации будет возвращена на страницу.

### Событие: 'gpu-info-update'

Выдается при каждом обновлении информации о GPU.

### Событие: 'gpu-процесс-crashed' _Deprecated_

Возвращает:

* `event` Event
* `killed` Boolean

Возникает, когда процесс GPU аварийно завершает работу или завершается принудительно.

**Устарело:** Это событие заменяется событием `child-process-gone`, которое содержит больше информации о том, почему дочерний процесс исчез. Это не всегда, потому что он разбился. На `killed` boolean можно заменить проверки `reason === 'killed'` при переходе на это событие.

### Событие: 'renderer-процесс-crashed' _Deprecated_

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)
* `killed` Boolean

Происходит, когда графический процесс `webContents` аварийно завершает работу или является убитым.

**:** Это событие затухает событие `render-process-gone` , содержит больше информации о том, почему процесс визуализации исчез. Это не всегда, потому что он разбился.  На `killed` boolean можно заменить проверки `reason === 'killed'` при переходе на это событие.

### Событие: 'рендер-процесс-ушел'

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)
* `details` объект
  * `reason` Строка - Причина, по которой процесс рендеров исчез.  Возможные значения:
    * `clean-exit` - Процесс вышел с кодом выхода нуля
    * `abnormal-exit` - Процесс вышел с ненулевой код выхода
    * `killed` - Процесс был отправлен SIGTERM или иным образом убит извне
    * `crashed` - Процесс разбился
    * `oom` - Процесс закончился в памяти
    * `launch-failed` - Процесс так и не был успешно запущен
    * `integrity-failure` - Проверки целостности кода Windows не удалось
  * `exitCode` Integer - Код выхода процесса, если `reason` не `launch-failed`, и в этом случае `exitCode` будет платформы конкретных код ошибки запуска.

Испускаемый при процессе рендерера неожиданно исчезает.  Это, как правило потому что он разбился или погиб.

### Событие 'child-process-gone'

Возвращает:

* `event` Event
* `details` объект
  * `type` String - Тип процесса. Одно из следующих значений:
    * `Utility`
    * `Zygote`
    * `Sandbox helper`
    * `GPU`
    * `Pepper Plugin`
    * `Pepper Plugin Broker`
    * `Unknown`
  * `reason` String - Причина исчезновения дочернего процесса. Возможные значения:
    * `clean-exit` - Процесс вышел с кодом выхода нуля
    * `abnormal-exit` - Процесс вышел с ненулевой код выхода
    * `killed` - Процесс был отправлен SIGTERM или иным образом убит извне
    * `crashed` - Процесс разбился
    * `oom` - Процесс закончился в памяти
    * `launch-failed` - Процесс так и не был успешно запущен
    * `integrity-failure` - Проверки целостности кода Windows не удалось
  * `exitCode` - Код выхода для процесса (например, статус от waitpid, если на posix, от GetExitCodeProcess на Windows).
  * `serviceName` String (по желанию) - не локализованное название процесса.
  * `name` String (опционально) - Название процесса. Например: `Audio Service`, `Content Decryption Module Service`, `Network Service`, `Video Capture` и т.д.

Испускаемый, когда процесс ребенка неожиданно исчезает. Это, как правило потому что он разбился или погиб. Он не включает процессы рендерера.

### Событие: 'accessibility-support-changed' _macOS_ _Windows_

Возвращает:

* `event` Event
* `accessibilitySupportEnabled` Boolean - `true`, когда поддержка доступности Chrome включена, иначе `false`.

Возникает при изменении Chrome поддержки специальных возможностей. Это событие срабатывает, когда вспомогательные технологии, такие как устройства чтения с экрана, включены или отключены. Смотрите https://www.chromium.org/developers/design-documents/accessibility для подробностей.

### Событие: 'session-created'

Возвращает:

* `session` [Session](session.md)

Происходит после создания новой сессии `session`.

```javascript
const { app } требует ('электрон')

app.on ('сессия-создан', (сессия) ->
  консоль.log (сессия)
)
```

### Событие: 'second-instance'

Возвращает:

* `event` Event
* `argv` String [] - массив аргументов командной строки вторичных экземпляров
* `workingDirectory` String - рабочий каталог вторичных экземпляров

Это событие произойдет внутри главного экземпляра Вашего приложения, когда второй экземпляр был запущен и вызывает `app.requestSingleInstanceLock()`.

`argv` это массив аргументов командной строки второго экземпляра, а `workingDirectory` это текущая рабочая директория. Обычно приложения реагируют на это, делая их основное окно сфокусированным и развернутым.

**Примечание:** Если второй экземпляр запускается другим пользователем, массив `argv` не будет содержать аргументы.

Это событие гарантировано происходит после события `ready` в `app`.

**Примечание:** Дополнительные аргументы командной строки могут быть добавлены Chromium, такие как `--original-process-start-time`.

### Событие: 'desktop-capturer-get-sources'

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)

Возникает, когда `desktopCapturer.getSources()` вызывается в процессе рендерера `webContents`. Вызов `event.preventDefault()` вернет пустые источники.

### Событие: «дистанционное требует» _Deprecated_

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)
* `moduleName` String

Происходит когда функция `remote.require()` вызвана в процессе рендеринга `webContents`. Вызов `event.preventDefault()` предотвращает возврат модуля. Пользовательское значение может быть возвращено, если установить его в `event.returnValue`.

### Событие: «дистанционно-получить-глобальный» _Deprecated_

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)
* `globalName` String

Происходит когда функция `remote.getGlobal()` вызвана в процессе рендеринга `webContents`. Вызов `event.preventDefault()` предотвращает возврат глобального значения. Пользовательское значение может быть возвращено, если установить его в `event.returnValue`.

### Событие: 'удаленный-получить-builtin' _Deprecated_

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)
* `moduleName` String

Происходит когда функция `remote.getBuiltin()` вызвана в процессе рендеринга `webContents`. Вызов `event.preventDefault()` предотвращает возврат модуля. Пользовательское значение может быть возвращено, если установить его в `event.returnValue`.

### Событие: 'дистанционное начало-текущее окно' _Deprecated_

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)

Происходит когда функция `remote.getCurrentWindow()` вызвана в процессе рендеринга `webContents`. Вызов `event.preventDefault()` предотвращает возврат объекта. Пользовательское значение может быть возвращено, если установить его в `event.returnValue`.

### Событие: "дистанционное получить-текущий-веб-содержимое" _Deprecated_

Возвращает:

* `event` Event
* `webContents` [WebContents](web-contents.md)

Происходит когда функция `remote.getCurrentWebContents()` вызвана в процессе рендеринга `webContents`. Вызов `event.preventDefault()` предотвращает возврат объекта. Пользовательское значение может быть возвращено, если установить его в `event.returnValue`.

## Методы

Объект `app` имеет следующие методы:

**Примечание:** Некоторые методы доступны только в определенных операционных системах и помечены как таковые.

### `app.quit()`

Попробуйте закрыть все окна. Сначала возникнет событие `before-quit`. Если все окна успешно закрыты, событие `will-quit` возникнет и по умолчанию приложение будет завершено.

Этот метод гарантирует, что все обработчики событий `beforeunload` и ` unload` выполнятся корректно. Вполне возможно, что окно отменит выход, возвращая `false` в обработчике событий `beforeunload`.

### `app.exit([exitCode])`

* `exitCode` Integer (опционально)

Немедленный выход с помощью `exitCode`. `exitCode` по умолчанию 0.

Все окна будут закрыты немедленно, без разрешения пользователя, а также события `before-quit` и `will-quit` не будут происходить.

### `app.relaunch([options])`

* `options` Object (опционально)
  * `args` String[] (опционально)
  * `execPath` String (опиционально)

Перезапуск приложения когда существует текущий экземпляр.

По умолчанию, новый экземпляр будет использовать ту же самую рабочую директорию и аргументы командной строки, что и текущий экземпляр. Когда `args` указан, `args` передаются как аргументы командной строки. Когда задано значение `execPath`, `execPath` будет выполняться для перезапуска вместо текущего приложения.

Обратите внимание, что этот метод не завершает приложение при выполнении, вам нужно вызвать `app.quit` или `app.exit` после вызова `app.relaunch` чтобы перезапустить приложение.

Когда `app.relaunch` вызывается несколько раз, несколько экземпляров будет запущено после выхода из текущего экземпляра.

Пример перезапуска немедленно текущего экземпляра и добавив новый аргумент командной строки в новый экземпляр:

```javascript
const { app } = require('electron')

app.relaunch({ args: process.argv.slice(1).concat(['--relaunch']) })
app.exit(0)
```

### `app.isReady()`

Возвращает `Boolean` - `true,` если Electron завершил инициализацию, `false` в противном случае. См. также `app.whenReady()`.

### `app.whenReady()`

Возвращает `Promise<void>` - выполняется при инициализации Electron. Может быть использован в качестве удобной альтернативы проверки `app.isReady()` и подписывания на событие `ready`, если приложение еще не готово.

### `app.focus([options])`

* `options` Object (опционально)
  * `steal` Boolean _macOS_ - Сделайте приемник активным приложением, даже если другое приложение в настоящее активен.

На Linux, фокусируется на первом видимом окне. На macOS, делает приложение активное приложение. В Windows основное внимание уделяется первому окну приложения.

Вы должны стремиться использовать `steal` как можно экономно.

### `app.hide()` _macOS_

Скрывает все окна приложения, не минимизируя их.

### `app.show()` _macOS_

Показывает окна приложений после того, как они были скрыты. Автоматически не фокусируется них.

### `app.setAppLogsPath([path])`

* `path` String (необязательно) - пользовательский путь для журналов. Должно быть, абсолютно.

Устанавливает или создает каталог логов Вашего приложения, которые затем могут быть обработаны с помощью `app.getPath()` или `app.setPath(pathName, newPath)`.

Вызов `app.setAppLogsPath()` без параметра `path` приведет к тому, что этот каталог будет установлен на `~/Library/Logs/YourAppName` на _macOS_, и внутри директории `userData` на _Linux_ и _Windows_.

### `app.getAppPath()`

Возвращает `String` - текущего каталога приложения.

### `app.getPath(name)`

* `name` Строка - Вы можете запросить следующие пути по имени:
  * `home` домашний каталог пользователя.
  * `appData` каталог данных приложения Per-user, который по умолчанию указывает на:
    * `%APPDATA%` на Windows
    * `$XDG_CONFIG_HOME` или `~/.config` на Linux
    * `~/Library/Application Support` на macOS
  * `userData` каталог для хранения файлов конфигурации вашего приложения, которые по умолчанию является `appData` добавляется с именем вашего приложения.
  * `кеш`
  * ` temp ` временный каталог.
  * `exe` текущий исполняемый файл.
  * `module` библиотека `libchromiumcontent`.
  * `desktop` каталог рабочего стола, текущего пользователя.
  * `documents` каталог пользователя "My Documents".
  * `downloads` Каталог пользователя "Downloads".
  * `music` каталог пользователя "Music".
  * `pictures` каталог пользователя для фотографии.
  * `videos` каталог пользователя для видео.
  * `recent` каталог для последних файлов пользователя (только Windows).
  * `logs` директория для логов вашего приложения.
  * `crashDumps` каталог, где хранятся свалки.

Возвращает `String` - Путь к специальному каталогу или файлу, связанному с `name`. На неудачи `Error` брошена .

Если `app.getPath('logs')` вызывается без имени `app.setAppLogsPath()`, то сначала создается каталог журнала по умолчанию, эквивалентный вызову `app.setAppLogsPath()` без параметра `path`.

### `app.getFileIcon(path[, options])`

* `path` String
* `options` Object (опционально)
  * `size` Струна
    * `small` - 16x16
    * `normal` - 32x32
    * `large` - 48x48 on _Linux_, 32x32 on _Windows_, не поддерживается на _macOS_.

Возвращает `Promise<NativeImage>` - содержащий иконку приложения, которая является [NativeImage](native-image.md).

Извлекает путь значка.

На _Windows_, там 2 вида значков:

* Значки, связанные с определенными расширениями, как `.mp3`, `.png`, и т.д.
* Значки внутри файла, как `.exe`, `.dll`, `.ico`.

На _Linux_ и _macOS_ иконки зависят от приложения, ассоциируемого с mime-типом файла.

### `app.setPath(name, path)`

* `name` String
* `path` String

Переопределяет `path` в специальный каталог или файл, связанный с `name`. Если путь задает каталог, который не существует, то при вызове выбросится `Error`. В этом случае каталог должен быть создан с помощью `fs.mkdirSync` или аналогичным способом.

Можно переопределять только пути `name`, определенное в `app.getPath`.

По умолчанию cookies и кэш веб-страницы будут храниться в каталоге `userData`. Если вы хотите изменить это расположение, вам необходимо переопределить путь `userData` прежде, чем событие `ready` модуля `app` возникнет.

### `app.getVersion()`

Возвращает `String` - версии загруженного приложения. Если версия не найдена в файле `package.json` приложения, возвращается версия текущего пакета или исполняемого файла.

### `app.getName()`

Возвращает `String` - имя текущего приложения, который является именем в файле приложения `package.json`.

Обычно поле `name` в `package.json` является коротким именем, написанном в нижнем регистре, согласно спецификации модулей npm. Обычно Вы должны также указать поле `productName`, которое пишется заглавными буквами - имя вашего приложения, и которое будет предпочтительнее `name` для Electron.

### `app.setName(name)`

* `name` String

Переопределяет имя текущего приложения.

**Примечание:** Эта функция перекрывает имя, используемое внутри Electron; это не влияет на имя, которое использует ОС.

### `app.getLocale()`

Возвращает `String` - Текущая локализация приложения. Возможные значения возврата задокументированы [здесь](locales.md).

Для установки языка вам потребуется использовать переключатель командной строки во время запуска приложения, который можно найти [здесь](https://github.com/electron/electron/blob/master/docs/api/command-line-switches.md).

**Примечание:** При распространении упакованного приложения, нужно также добавить папку `locales`.

**Примечание** На Windows Вы должны вызывать этот метод после того, как событие `ready` произойдет.

### `app.getLocaleCountryCode()`

Возвращает `String` - Локализация двухкилогового кода [ISO 3166](https://www.iso.org/iso-3166-country-codes.html) пользователя. Значение взято из РОДНЫХ API ОС.

**Примечание:** Когда невозможно определить код страны языка, возвращает пустую строку.

### `app.addRecentDocument(path)` _macOS_ _Windows_

* `path` String

Добавляет `path` к списку последних документов.

Этот список управляется ОС. На Windows, вы можете посетить список из задачи , и на macOS, вы можете посетить его из меню док-станции.

### `app.clearRecentDocuments()` _macOS_ _Windows_

Очищает список последних документов.

### `app.setAsDefaultProtocolClient(protocol[, path, args])`

* `protocol` String - имя вашего протокола, без `://`. Например, если вы хотите, чтобы ваше приложение `electron://` ссылки, назовите этот метод `electron` в качестве параметра.
* `path` Строка (не _)_ Windows - Путь к электрону выполняется. По умолчанию `process.execPath`
* `args` String ( необязательно) _Windows_ - Аргументы перешли к исполнению. По умолчанию пустой массив

Возвращает `Boolean` - был ли вызов успешным.

Устанавливает текущий выполняется в качестве обработчика по умолчанию для протокола (ака URI схеме). Это позволяет интегрировать приложение глубже в операционную систему. После регистрации все связи с `your-protocol://` будут открыты с текущей текущей. Вся ссылка, включая протокол, будет передана вашему в качестве параметра.

**Примечание:** На macOS можно регистрировать только протоколы, которые были добавлены в в `info.plist`, которые не могут быть изменены во время выполнения. Тем не менее, изменить файл во время сборки через [Electron Forge][electron-forge], [Electron Packager][electron-packager], или путем редактирования `info.plist` с текстовым редактором. За подробными сведениями обращайтесь к [документации компании Apple][CFBundleURLTypes].

**Примечание:** В окружении Windows Store (когда упаковано как `appx`) этот метод вернет `true` для всех вызовов, но ключ реестра, который он устанавливает, не будет доступен другим приложениям.  Чтобы зарегистрировать Ваше приложения в Windows Store как обработчик протокола по умолчанию, Вы должны [объявить протокол в Вашем манифесте](https://docs.microsoft.com/en-us/uwp/schemas/appxpackage/uapmanifestschema/element-uap-protocol).

API использует реестр Windows и `LSSetDefaultHandlerForURLScheme` внутренне.

### `app.removeAsDefaultProtocolClient(protocol[, path, args])` _macOS_ _Windows_

* `protocol` String - имя вашего протокола, без `://`.
* `path` String (optional) _Windows_ - по умолчанию `process.execPath`
* `args` String[] (optional) _Windows_ - по умолчанию пустой массив

Возвращает `Boolean` - был ли вызов успешным.

Этот метод проверяет, выполняется ли ток в качестве обработчика по умолчанию для (ака схема URI). Если это так, он будет удалить приложение в качестве обработчика по умолчанию.

### `app.isDefaultProtocolClient(protocol[, path, args])`

* `protocol` String - имя вашего протокола, без `://`.
* `path` String (optional) _Windows_ - по умолчанию `process.execPath`
* `args` String[] (optional) _Windows_ - по умолчанию пустой массив

Возвращает `Boolean` - Является ли текущий выполненный обработчик по умолчанию для (ака URI схеме).

**Примечание:** На macOS можно использовать этот метод для проверки, если приложение было зарегистрировано в качестве обработчика протокола по умолчанию для протокола. Вы также можете проверить это, установив `~/Library/Preferences/com.apple.LaunchServices.plist` на машине macOS. За подробными сведениями обращайтесь к [документации компании Apple][LSCopyDefaultHandlerForURLScheme].

API использует реестр Windows и `LSCopyDefaultHandlerForURLScheme` внутренне.

### `app.getApplicationNameForProtocol(url)`

* `url` String - URL-адрес с именем протокола для проверки. В отличие от методов в этой семье, это принимает весь URL, в `://` с минимумом (например. `https://`).

Возвращает `String` - Название приложения, обработавав протокол, или пустой строки, если нет обработчика. Например, если Electron является обработчиком по умолчанию, это может быть `Electron` на Windows и Mac. Однако не полагаться на точный формат, который не гарантированно останется неизменным. Ожидайте другой формат на Linux, возможно, с `.desktop` суффиксом.

Этот метод возвращает имя приложения обработчика по умолчанию для протокола (ака URI схема) URL.

### `app.getApplicationInfoForProtocol(url)` _macOS_ _Windows_

* `url` String - URL-адрес с именем протокола для проверки. В отличие от методов в этой семье, это принимает весь URL, в `://` с минимумом (например. `https://`).

Возвращает `Promise<Object>` - Разрешить с объектом, содержащим следующее:

* `icon` NativeImage - значок отображения приложения, обгоняя протокол.
* `path` String - путь установки приложения, обгоняя протокол.
* `name` String - отображение имени приложения, обуговаемого протоколом.

Этот метод возвращает обещание, которое содержит имя приложения, значок и путь обработчика по умолчанию для (ака URI схема) URL.

### `app.setUserTasks(tasks)` _Windows_

* `tasks` [Task[]](structures/task.md) - массив объектов `Task`

Добавляет `tasks` к категории [Tasks][tasks] в JumpList на Windows.

`tasks` массив объектов [`Task`](structures/task.md).

Возвращает `Boolean` - был ли вызов успешным.

**Примечание:** Если вы хотите настроить Jump List еще больше используйте `app.setJumpList(categories)`.

### `app.getJumpListSettings()` _Windows_

Возвращает `Object`:

* `minItems` Integer - минимальное количество элементов, которые будут показаны в Jump List (для более подробного описания этого значение см. [документация MSDN][JumpListBeginListMSDN]).
* `removedItems` [JumpListItem []](structures/jump-list-item.md) - массив объектов `JumpListItem`, которые соответствуют элементам, которые пользователь явно удалил из настраиваемых категорий в Jump List. Эти элементы не должны быть снова добавлены в Jump List, при **следующем** вызове `app.setJumpList()`, Windows не будет отображать любую настраиваемую категорию, содержащую любой из удаленных пунктов.

### `app.setJumpList(categories)` _Windows_

* `categories` [JumpListCategory[]](structures/jump-list-category.md) | `null` - массив типа `JumpListCategory`, состоящий из объектов.

Задает или удаляет пользовательский список переходов для приложения и возвращает одну из следующих строк:

* `ok` - ничего не случилось.
* `error` - произошла одна или несколько ошибок, включите ведение журнала выполнения, чтобы выяснить возможную ошибку.
* `invalidSeparatorError` - Была предпринята попытка добавить сепаратор в пользовательскую категорию в списке перепрыгивок. Сепараторы допускаются только в стандартной `Tasks` категории.
* `fileTypeRegistrationError` - была сделана попытка добавить ссылку на файл в список переходов для типа файла, который в приложении не зарегистрирован для обработки.
* `customCategoryAccessDeniedError` - пользовательские категории не могут быть добавлены в список переходов из-за ограничений конфиденциальности пользователей или групповой политики.

Если `categories` - `null`, то ранее установленный пользовательский список переходов (если таковой имеется) будет заменён стандартным списком переходов для приложения (управляется Windows).

**Примечание:** Если объект `JumpListCategory` не имеет ни `type`, ни `name` свойства, тогда `type` считается как `tasks`. Если свойство `name` установлено, но свойство `type` опущено, тогда `type` считается `custom`.

**Примечание:** Пользователи могут удалять элементы из пользовательских категорий, но Windows не будет позволять возвращать удаленный элемент в пользовательскую категорию до **следующего** удачного вызова `app.setJumpList(categories)`. Любая попытка вновь добавить удаленный элемент в пользовательскую категорию перед тем, как метод выполнится, приведёт к исключению всей категории из списка переходов. Список удаленных элементов можно получить с помощью `app.getJumpListSetting()`.

**Note:** The maximum length of a Jump List item's `description` property is 260 characters. Beyond this limit, the item will not be added to the Jump List, nor will it be displayed.

Вот очень простой способ, как создать пользовательский список переходов:

```javascript
const { app } - требуют ('электрон')

app.setJumpList (тип
    
  : 'обычай',
    имя: 'Последние проекты',
    элементы:
      - тип: 'файл', путь: 'C: 'Проекты'project1.proj',
      тип: 'файл', путь: 'C: 'Проекты'project2.proj' -
    ,
  ,
  // имеет имя, так что 'тип' считается "обычай"
    имя: 'Tools',
    элементов:


        название: 'Tool A',
        программа: process.execPath,
        args: '--run-tool-a', значок
        : process.execPath,
        iconIndex: 0, описание
        : 'Runs Tool A'
      ,

        : 'задача',
        название: 'Tool B',
        программа: process.execPath,
        args: '-run-tool-b', значок
        : process.execPath,
        iconIndex: 0,
        описание: 'Runs Tool B'
    


  { type: 'frequent' },
  / / не имеет имени и не тип так "тип", как предполагается, "задачи"
    пунктов:
      и
        типа: "задача",
        название: "Новый проект",
        программа: process.execPath,
        args: '-новый проект',
        описание: 'Создать новый проект.'
      Вопрос,
      { type: 'separator' },

        тип: "задача",
        название: "Восстановить проект",
        программа: process.execPath,
        args: '--восстановить-проект', описание
        : 'Восстановить проект'


  

```

### `app.requestSingleInstanceLock()`

Возвращает `Boolean`

Значение, которое возвращает этот метод, указывает, успешно или нет экземпляр Вашего приложения получило блокировку.  Если не удалось получить блокировку, можно предположить, что другой экземпляр Вашего приложения уже запущен с блокировкой и немедленно выходит.

Например. This method returns `true` if your process is the primary instance of your application and your app should continue loading.  Возвращает `false`, если Ваш процесс должен немедленно завершиться, так как он отправил свои параметры другому экземпляру, которые уже приобрел блокировку.

На macOS система автоматически обеспечивает единственный экземпляр, когда пользователи пытаются открыть второй экземпляра Вашего приложения в Finder, для этого будут происходить `open-file` и `open-url` события. Так или иначе, когда пользователи запустят Ваше приложение через командную строку, системный механизм единственного экземпляра будет обойден, и Вы должны использовать этот метод, чтобы обеспечить единственный экземпляр.

Пример активации окна единственного экземпляра, при запуске второго экземпляра:

```javascript
const { app } = require('electron')
let myWindow = null

const gotTheLock = app.requestSingleInstanceLock()

if (!gotTheLock) {
  app.quit()
} else {
  app.on('second-instance', (event, commandLine, workingDirectory) => {
    // Кто-то пытался запустить второй экземпляр, мы должны сфокусировать наше окно.
    if (myWindow) {
      if (myWindow.isMinimized()) myWindow.restore()
      myWindow.focus()
    }
  })

  // Создать myWindow, загрузить остальную часть приложения, и т.д.
  app.whenReady ().., то (()> -
    myWindow - создатьWindow ()
  )

```

### `app.hasSingleInstanceLock()`

Возвращает `Boolean`

Этот метод возвращает состояние, является или нет экземпляр Вашего приложения в данный момент, удерживающим блокировку единственного экземпляра.  Вы можете запросить блокировку с помощью `app.requestSingleInstanceLock()` и освободить с помощью `app.releaseSingleInstanceLock()`

### `app.releaseSingleInstanceLock()`

Releases all locks that were created by `requestSingleInstanceLock`. This will allow multiple instances of the application to once again run side by side.

### `app.setUserActivity(type, userInfo[, webpageURL])` _macOS_

* `type` String - уникально идентифицирует действие. Карты для [`NSUserActivity.activityType`][activity-type].
* `userInfo` any- специфичное, для приложения, состояние для использования другими устройствами.
* `webpageURL` String (необязательно) - веб-страница для загрузки в браузере, если не приложение не установлено на устройстве возобновления. Схема должна быть `http` или `https`.

Создает `NSUserActivity` и задает её в качестве текущей активности. Активность позже имеет право для [Handoff][handoff] на другом устройстве.

### `app.getCurrentActivityType()` _macOS_

Возвращает `String` - тип текущей выполняемой активности.

### `app.invalidateCurrentActivity()` _macOS_

Аннулирует текущую [Handoff][handoff] активность пользователя.

### `app.resignCurrentActivity()` _macOS_

Помечает текущую [Handoff][handoff] активность пользователя как неактивную без ее отмены.

### `app.updateCurrentActivity(type, userInfo)` _macOS_

* `type` String - уникально идентифицирует действие. Карты для [`NSUserActivity.activityType`][activity-type].
* `userInfo` any- специфичное, для приложения, состояние для использования другими устройствами.

Обновляет текущую активность, если ее тип соответствует `type`, объединяя записи с `userInfo` в свой текущий словарь `userInfo`.

### `app.setAppUserModelId(id)` _Windows_

* `id` String

Изменяет [Application User Model ID][app-user-model-id] на `id`.

### `app.setActivationPolicy(policy)` _macOS_

* `policy` String - может быть "регулярным", "аксессуаром" или "запрещенным".

Sets the activation policy for a given app.

Activation policy types:

* 'обычный' - Приложение является обычным приложением, которое появляется в доке и может иметь пользовательский интерфейс.
* 'аксессуар' - Приложение не появляется в доке и не имеет бара меню, но оно может быть активировано программно или при нажатии на одно из его окон.
* 'запрещено' - Приложение не появляется в доке и не может создавать окна или быть активировано.

### `app.importCertificate(options, callback)` _Linux_

* `options` Object
  * `certificate` String - путь к pkcs12 файлу.
  * `password` String - парольная фраза для сертификата.
* `callback` Function
  * `result` Integer - результат импорта.

Импорт сертификата в формате pkcs12 из платформы хранилища сертификатов. `callback` вызывается с `result` - результат операции импорта, значение `0` указывает на успех, все другие значения указывают на ошибку в соответствии со списком [net_error_list](https://source.chromium.org/chromium/chromium/src/+/master:net/base/net_error_list.h) в Chromium.

### `app.disableHardwareAcceleration()`

Отключает аппаратное ускорение для текущего приложения.

Этот метод может быть вызван только до того, как приложение будет готово.

### `app.disableDomainBlockingFor3DAPIs()`

By default, Chromium disables 3D APIs (e.g. WebGL) until restart on a per domain basis if the GPU processes crashes too frequently. This function disables that behavior.

Этот метод может быть вызван только до того, как приложение будет готово.

### `app.getAppMetrics()`

Возвращает [`ProcessMetric[]`](structures/process-metric.md): массив объектов `ProcessMetric`, которые соответствует статистике использования памяти и CPU всех процессов, связанных с приложением.

### `app.getGPUFeatureStatus()`

Возвращает [`GPUFeatureStatus`](structures/gpu-feature-status.md) - статус функции графики из `chrome://gpu/`.

**Примечание:** Эта информация может использоваться только после возникновения события `gpu-info-update`.

### `app.getGPUInfo(infoType)`

* `infoType` String - Может быть `basic` или `complete`.

Возвращает `Promise<unknown>`

Для `infoType` равным `complete`: Промис выполняется с `объектом`, содержащий всю GPU информацию как в [объекте GPUInfo в chromium](https://chromium.googlesource.com/chromium/src/+/4178e190e9da409b055e5dff469911ec6f6b716f/gpu/config/gpu_info.cc). Это включает информацию о версии и драйвере, показанную на странице `chrome://gpu`.

Для `infoType` равным `basic`: Промис выполняется с `объектом`, содержащий меньшее количество атрибутов, чем когда запрашивается с `complete`. Вот пример базового ответа:

```js
-
  auxAttributes:
   и
     завораживают: правда,
     canSupportThreadedTextureMailbox: ложный,
     прямойКомпозиция: ложный,
     прямойRendering: true,
     glResetNotificationStrategy: 0,
     inProcessGpu: правда,
     initializationTime: 0,
     jpegDecodeAcceleratoratorSupported: ложный,
     optimus: ложный, ложный,
     passthroughCmdDecoder: ложный,
     песочница: ложный,
     softwareRendering: ложный,
     поддерживаетOverlays: ложные,
     videoDecodeAcceleratorFlags: 0
   К,
  gpuDevice:
{ active: true, deviceId: 26657, vendorId: 4098 },
     { active: false, deviceId: 3366, vendorId: 32902 },
  machineModelName: 'MacBookPro',
  machineModelVersion: '11.5'

```

Использование `basics` должно быть предпочтительным, если требуется только основная информация, такая как `vendorId` или `driverId`.

### `app.setBadgeCount([count])` _Linux_ _macOS_

* `count` Integer (по желанию) - Если значение предоставлено, установите значок на предоставленное значение в противном случае, на macOS, отобразить простую белую точку (например, неизвестное количество уведомлений). На Linux, если значение не предоставляется значок не будет отображаться.

Возвращает `Boolean` - был ли вызов успешным.

Sets the counter badge for current app. Setting the count to `0` will hide the badge.

На macOS отображается на иконке в Dock. На Linux работает только для лаунчера Unity.

**Примечание:** Unity требует существования файла `.desktop` для работы, для получения дополнительной информации, пожалуйста, прочитайте [Desktop Environment Integration][unity-requirement].

### `app.getBadgeCount()` _Linux_ _macOS_

Возвращает `Integer` - текущее значение, отображаемое в значке счётчика.

### `app.isUnityRunning()` _Linux_

Возвращает `Boolean` - является ли текущее окружение рабочего стола Unity.

### `app.getLoginItemSettings([options])` _macOS_ _Windows_

* `options` Object (опционально)
  * `path` Строка (необязательно) _Windows_ - выполненный путь для сравнения. По умолчанию `process.execPath`.
  * `args` String( необязательно) _Windows_ - Аргументы командной строки для сравнения против. По умолчанию пустой массив.

Если Вы предоставили параметры `path` и `args` в `app.setLoginItemSettings`, тогда Вам необходимо передать те же аргументы сюда, чтобы `openAtLogin` установилось корректно.

Возвращает `Object`:

* `openAtLogin` Boolean - `true` если приложение планируется открыть при входе в систему.
* `openAsHidden` Boolean _macOS_ - `true` , если приложение будет открыто как скрытое при входе. Эта настройка недоступна на [MAS][mas-builds].
* `wasOpenedAtLogin` Boolean _macOS_ - `true` если приложение было открыто при входе автоматически. Эта настройка недоступна на [MAS][mas-builds].
* `wasOpenedAsHidden` Boolean _macOS_ - `true` если приложение было открыто в качестве скрытого входа элемент. Это означает, что приложению не следует открывать любое окно при запуске. Эта настройка недоступна на [MAS][mas-builds].
* `restoreState` Boolean _macOS_ - `true` если приложение было открыто в качестве элемента входа, должен восстановить состояние с предыдущей сессии. Это означает, что приложение должно восстановить окна, которые были открыты в последний раз, когда приложение было закрыто. Эта настройка недоступна на [MAS][mas-builds].
* `executableWillLaunchAtLogin` Boolean _Windows_ - `true` если приложение будет открыто при входе и его ключ запуска не будет отключен. Это отличается от `openAtLogin` , поскольку он игнорирует `args` вариант, это свойство будет верно, если данный выполненный будет запущен при входе с **любыми** аргументами.
* `launchItems` объект _Windows_
  * `name` Строка _Windows_ - значение имени входа в реестр.
  * `path` строка _Windows_ - выполняется для приложения, которое соответствует записи реестра.
  * `args` String _Windows_ - аргументы командной строки, чтобы перейти к исполнению.
  * `scope` String _Windows_ - один из `user` или `machine`. Указывает, находится ли запись в реестре под `HKEY_CURRENT USER` или `HKEY_LOCAL_MACHINE`.
  * `enabled` Boolean _Windows_ - `true` если ключ реестра приложений одобрен и, следовательно, показывает, `enabled` в настройках Task Manager и Windows.

### `app.setLoginItemSettings(settings)` _macOS_ _Windows_

* `settings` объект
  * `openAtLogin` Boolean (необязательно) - `true` открыть приложение при входе, `false` удалить приложение в качестве элемента входа. Defaults to `false`.
  * `openAsHidden` Boolean (по _)_ macOS  - `true` открыть приложение как скрытое. Значение по умолчанию: `false`. Пользователь может редактировать этот параметр в системных настройках, так что `app.getLoginItemSettings().wasOpenedAsHidden` должно быть проверено, когда приложение открыто, чтобы узнать текущее значение. Эта настройка недоступна на [MAS][mas-builds].
  * `path` String (необязательно) _Windows_ - выполняется для запуска при входе. По умолчанию `process.execPath`.
  * `args` String (по желанию) _Windows_ - Аргументы командной строки, чтобы передать выируемому. По умолчанию пустой массив. Позаботьтесь, чтобы обернуть пути в котировки.
  * `enabled` Boolean ( _)_ Windows `true` - изменит ключ реестра, утвержденный стартапом, `enable / disable` приложение в настройках Task Manager и Windows. Defaults to `true`.
  * `name` String (необязательно) _Windows_ - значение имени для записи в реестр. По умолчанию appUserModelId приложения (). Установите приложению параметры при входе в систему.

Для работы с Electron `autoUpdater` на Windows, который использует [Squirrel][Squirrel-Windows], вы можете задать путь запуска Update.exe и передавать аргументы, которые указывают на имя приложения. Например:

``` javascript
const appFolder = path.dirname(process.execPath)
const updateExe = path.resolve(appFolder, '..', 'Update.exe')
const exeName = path.basename(process.execPath)

app.setLoginItemSettings({
  openAtLogin: true,
  path: updateExe,
  args: [
    '--processStart', `"${exeName}"`,
    '--process-start-args', `"--hidden"`
  ]
})
```

### `app.isAccessibilitySupportEnabled()` _macOS_ _Windows_

Возвращает `Boolean` - `true` если включена поддержка специальных возможностей Chrome, и `false` в противном случае. Этот API будет возвращать `true`, если обнаружено использование вспомогательных технологий, таких как средства чтения с экрана. Смотрите https://www.chromium.org/developers/design-documents/accessibility для подробностей.

### `app.setAccessibilitySupportEnabled(enabled)` _macOS_ _Windows_

* `enabled` Boolean - включить или отключить отрисовку [древа специальных возможностей](https://developers.google.com/web/fundamentals/accessibility/semantics-builtin/the-accessibility-tree)

Вручную включает поддержку специальных возможностей от Chrome, позволяя пользователям открывать специальные возможности в настройках приложения. Смотрите [документацию специальных возможностей Chromium](https://www.chromium.org/developers/design-documents/accessibility) для подробной информации. Отключено по умолчанию.

Этот API должен вызываться после того, как произошло событие `ready`.

**Note:** Rendering accessibility tree can significantly affect the performance of your app. It should not be enabled by default.

### `app.showAboutPanel()`

Show the app's about panel options. These options can be overridden with `app.setAboutPanelOptions(options)`.

### `app.setAboutPanelOptions(options)`

* `options` Object
  * `applicationName` String (опиционально) - имя приложения.
  * `applicationVersion` String (опиционально) - версия приложения.
  * `copyright` String (опиционально) - copyright информация.
  * `version` String (опционально) _macOS_ - номер версии сборки приложения.
  * `credits` String (по желанию) _macOS_ _Windows_ - Кредитная информация.
  * `authors` String[] (опционально) _Linux_ - список авторов приложения.
  * `website` String (опционально) _Linux_ - веб-сайт приложения.
  * `iconPath` String ( _)_ _Linux_ Windows  - Путь к значку приложения в формате ФАЙЛА JPEG или PNG. На Linux, будет показано как 64x64 пикселей при сохранении соотношения сторон.

Установите описание панели опций. This will override the values defined in the app's `.plist` file on macOS. Смотрите [Apple docs][about-panel-options] для получения более подробной информации. На Linux необходимо устанавливать все значения; по умолчанию значений нет.

If you do not set `credits` but still wish to surface them in your app, AppKit will look for a file named "Credits.html", "Credits.rtf", and "Credits.rtfd", in that order, in the bundle returned by the NSBundle class method main. The first file found is used, and if none is found, the info area is left blank. See Apple [documentation](https://developer.apple.com/documentation/appkit/nsaboutpaneloptioncredits?language=objc) for more information.

### `app.isEmojiPanelSupported()`

Возвращает `Boolean` - позволяет или нет текущая версия ОС выбирать нативные эмодзи.

### `app.showEmojiPanel()` _macOS_ _Windows_

Показывает нативный выбор эмодзи.

### `app.startAccessingSecurityScopedResource(bookmarkData)` _mas_

* `bookmarkData` String - закодированные в формате base64 данные защищенных закладок, возвращаемые методами `dialog.showOpenDialog` или `dialog.showSaveDialog`.

Возвращает `Function`. Эта функция **должна** быть вызвана после того, как Вам успешно удалось получить доступ к защищенному файлу. Если Вы забыли, запретить доступ к закладке, [возможно утечка ресурсов ядра](https://developer.apple.com/reference/foundation/nsurl/1417051-startaccessingsecurityscopedreso?language=objc) и ваше приложение потеряет свою способность выйти за пределы песочницы, пока не будет перезапущено.

```js
// Получение доступа к файлу.
const stopAccessingSecurityScopedResource - app.startAccessingSecurityScopedResource (данные)
// Теперь вы можете получить доступ к файлу за пределами песочницы 🎉

// Не забудьте прекратить доступ к файлу, как только вы закончите с ним.
stopAccessingSecurityScopedResource()
```

Начать доступ в области безопасности ресурса. С помощью этого метода Electron приложения, которые упакованы для Mac App Store, могут выходить на пределы их песочницы, чтобы получить файлы, выбранные пользователем. Подробное описание как работает эта система, смотри [Apple's documentation](https://developer.apple.com/library/content/documentation/Security/Conceptual/AppSandboxDesignGuide/AppSandboxInDepth/AppSandboxInDepth.html#//apple_ref/doc/uid/TP40011183-CH3-SW16).

### `app.enableSandbox()`

Включает полноценный режим песочницы в приложении. This means that all renderers will be launched sandboxed, regardless of the value of the `sandbox` flag in WebPreferences.

Этот метод может быть вызван только до того, как приложение будет готово.

### `app.isInApplicationsFolder()` _macOS_

Returns `Boolean` - Whether the application is currently running from the systems Application folder. Use in combination with `app.moveToApplicationsFolder()`

### `app.moveToApplicationsFolder([options])` _macOS_

* `options` Object (опционально)
  * `conflictHandler` функция<Boolean> (опционально) - обработчик потенциальных конфликтов при неудачных попытках.
    * `conflictType` String - Тип конфликта перемещения, с которым столкнулся обработчик; может быть `exists` или `existsAndRunning`, где `exists` означает, что приложение с тем же именем присутствует в каталоге приложений, а `existsAndRunning` означает, что он существует и работает в данный момент.

Returns `Boolean` - Whether the move was successful. Please note that if the move is successful, your application will quit and relaunch.

No confirmation dialog will be presented by default. Если нужно подтверждение операции пользователем, используйте [`dialog`](dialog.md) API.

**Примечание:** Этот метод вызывает ошибки, если что-нибудь, кроме пользователя, вызывает сбой перемещения. Например, если пользователь отменяет диалоговое окно авторизации, этот метод возвращает false. Если нам не удастся выполнить копирование, этот метод вызовет ошибку. Сообщение об ошибке должно быть информативным и скажет Вам, что действительно пошло не так.

По умолчанию, если приложение с тем же именем, что и перемещенное, существует в каталоге приложений и _не_ запущено, существующее приложение будет помещено в корзину, а активное приложение перемещено на его место. Если оно _работает_, на уже существующее запущенное приложение переместится фокус, а ранее активное приложение само завершит работу. Это поведение можно изменить, предоставив необязательный обработчик конфликтов, где логическое значение, возвращаемое обработчиком, определяет, будет ли конфликт перемещения разрешен с поведением по умолчанию.  то есть возврат `false` гарантирует, что дальнейшие действия не будут приняты, возврат `true` приведет к поведению по умолчанию и продолжению метода.

Например:

```js
app.moveToApplicationsFolder({
  conflictHandler: (conflictType) => {
    if (conflictType === 'exists') {
      return dialog.showMessageBoxSync({
        type: 'question',
        buttons: ['Halt Move', 'Continue Move'],
        defaultId: 0,
        message: 'An app of this name already exists'
      }) === 1
    }
  }
})
```

Будет означать, что если приложение уже существует в каталоге пользователя, если пользователь выберет 'Continue Move', то эта функция будет продолжена с поведением по умолчанию, и существующее приложение будет удалено и активное приложение будет перемещено на место.

### `app.isSecureKeyboardEntryEnabled()` _macOS_

Returns `Boolean` - whether `Secure Keyboard Entry` is enabled.

By default this API will return `false`.

### `app.setSecureKeyboardEntryEnabled(enabled)` _macOS_

* `enabled` Boolean - Включить или отключить `Secure Keyboard Entry`

Set the `Secure Keyboard Entry` is enabled in your application.

By using this API, important information such as password and other sensitive information can be prevented from being intercepted by other processes.

See [Apple's documentation](https://developer.apple.com/library/archive/technotes/tn2150/_index.html) for more details.

**Note:** Enable `Secure Keyboard Entry` only when it is needed and disable it when it is no longer needed.

## Свойства

### `app.accessibilitySupportEnabled` _macOS_ _Windows_

`Boolean` свойство, которое `true`, если поддержка специальных возможностей Chrome включена, иначе `false`. Это свойство будет `true`, если использование вспомогательных технологий, таких как средства чтения с экрана, были обнаружены. Устанавливая это свойство на `true`, вручную включает поддержку специальных возможностей Chrome, позволяя разработчикам показать пользователю переключатели специальных возможностей в настройках приложения.

See [Chromium's accessibility docs](https://www.chromium.org/developers/design-documents/accessibility) for more details. Отключено по умолчанию.

Этот API должен вызываться после того, как произошло событие `ready`.

**Note:** Rendering accessibility tree can significantly affect the performance of your app. It should not be enabled by default.

### `app.applicationMenu`

A `Menu | null`свойство, которое возвращает [`Menu`](menu.md) если оно было установлено, в противном случае возвращает `null`. Пользователи могут передать [Меню](menu.md), чтобы установить это свойство.

### `app.badgeCount` _Linux_ _macOS_

An `Integer` property that returns the badge count for current app. Setting the count to `0` will hide the badge.

On macOS, setting this with any nonzero integer shows on the dock icon. On Linux, this property only works for Unity launcher.

**Примечание:** Unity требует существования файла `.desktop` для работы, для получения дополнительной информации, пожалуйста, прочитайте [Desktop Environment Integration][unity-requirement].

**Примечание:** На macOS, вы должны убедиться, что ваше приложение имеет разрешение на отображение уведомлений.

### `app.commandLine` _Readonly_

Объект [`CommandLine`](./command-line.md), который позволяет читать и манипулировать аргументами командной строки, используемыми Chromium.

### `app.dock` _macOS_ _Readonly_

A [`Dock`](./dock.md) `| undefined` object that allows you to perform actions on your app icon in the user's dock on macOS.

### `app.isPackaged` _Readonly_

`Boolean` свойство, которое возвращает `true`, если приложение упаковано, `false` иначе. Для многих приложений это свойство может использоваться для отличия среды разработки и производства.

### `app.name`

Свойство `String`, указывающее имя текущего приложения, которое является именем в файле `package.json`.

Обычно поле `name` в `package.json` является коротким именем, написанном в нижнем регистре, согласно спецификации модулей npm. Обычно Вы должны также указать поле `productName`, которое пишется заглавными буквами - имя вашего приложения, и которое будет предпочтительнее `name` для Electron.

### `app.userAgentFallback`

`Строка`, которая является строкой агента пользователя, которую Electron будет использовать в качестве глобального запаса.

Это агент пользователя, который будет использоваться, если ни один агент пользователя не установлен на уровнях `webContents` или `session`.  Это полезно для того, чтобы все ваше приложение имело один и тот же пользовательский агент.  Установите пользовательское значение как можно раньше в инициализации Ваших приложений, чтобы убедиться, что используется переопределенное значение.

### `app.allowRendererProcessReuse`

`Boolean`, которое, когда `true`, отключает переопределения, которые Electron имеет на месте, чтобы убедиться, что графические процессы перезапускаются при каждой навигации.  Текущее значение по умолчанию для этого свойства - `true`.

Цель заключается в том, чтобы эти переопределения были отключены по умолчанию, а затем, в некоторой точке в будущем, это свойство будет удалено.  Это свойство влияет на то, какие нативные модули можно использовать в графическом процессе.  Для большей информации о том, как Electron перезапускает графический процесс и использует нативные модули в графическом процессе, пожалуйста, проверьте этот [отслеживаемый вопрос](https://github.com/electron/electron/issues/18397).

### `app.runningUnderRosettaTranslation` _macOS_ _Readonly_

A `Boolean` which when `true` indicates that the app is currently running under the [Rosetta Translator Environment](https://en.wikipedia.org/wiki/Rosetta_(software)).

You can use this property to prompt users to download the arm64 version of your application when they are running the x64 version under Rosetta incorrectly.

[tasks]: https://msdn.microsoft.com/en-us/library/windows/desktop/dd378460(v=vs.85).aspx#tasks
[app-user-model-id]: https://msdn.microsoft.com/en-us/library/windows/desktop/dd378459(v=vs.85).aspx
[electron-forge]: https://www.electronforge.io/
[electron-packager]: https://github.com/electron/electron-packager
[CFBundleURLTypes]: https://developer.apple.com/library/ios/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/TP40009249-102207-TPXREF115
[LSCopyDefaultHandlerForURLScheme]: https://developer.apple.com/library/mac/documentation/Carbon/Reference/LaunchServicesReference/#//apple_ref/c/func/LSCopyDefaultHandlerForURLScheme
[handoff]: https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/Handoff/HandoffFundamentals/HandoffFundamentals.html
[activity-type]: https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSUserActivity_Class/index.html#//apple_ref/occ/instp/NSUserActivity/activityType
[unity-requirement]: ../tutorial/desktop-environment-integration.md#unity-launcher
[mas-builds]: ../tutorial/mac-app-store-submission-guide.md
[Squirrel-Windows]: https://github.com/Squirrel/Squirrel.Windows
[JumpListBeginListMSDN]: https://msdn.microsoft.com/en-us/library/windows/desktop/dd378398(v=vs.85).aspx
[about-panel-options]: https://developer.apple.com/reference/appkit/nsapplication/1428479-orderfrontstandardaboutpanelwith?language=objc
