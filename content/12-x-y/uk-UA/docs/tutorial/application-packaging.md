# Пакування Застосунків

To mitigate [issues](https://github.com/joyent/node/issues/6960) around long path names on Windows, slightly speed up `require` and conceal your source code from cursory inspection, you can choose to package your app into an [asar][asar] archive with little changes to your source code.

Most users will get this feature for free, since it's supported out of the box by [`electron-packager`][electron-packager], [`electron-forge`][electron-forge], and [`electron-builder`][electron-builder]. Якщо ви не використовуєте жодного з інструментів, прочитайте на.

## Генерація `asar` Архів

An [asar][asar] archive is a simple tar-like format that concatenates files into a single file. Electron може читати довільні файли без розпакування всього файлу.

Кроки упаковки вашої програми в архів `asar`:

### 1. Встановити asar Utility

```sh
$ npm install -g asar
```

### 2. Пакунок з `asar pack`

```sh
$ asar пакунок Ваш додаток додаток .asar
```

## Використання `asar` Архівів

У Electron є два набори API: API Node передбачено Node.js та Web API, надані Chromium. Обидва API підтримують читання файлів від `asar` архів.

### API вузла

З спеціальними патчами в Electron, Node API типу `fs. eadFile` і `вимагають` ставитися до `asar` архіву як віртуальні каталоги, а також файли в ній, як і звичайні файли в файловій системі.

Наприклад, припустимо, ми маємо архів `example.asar` під купом `/path/to`:

```sh
$ asar list /path/to/example.asar
/app.js
/file.txt
/dir/module.js
/static/index.html
/static/main.css
/static/jquery.min.js
```

Читайте файл в архіві `asar`:

```javascript
const fs = require('fs')
fs.readFileSync('/path/to/example.asar/file.txt')
```

Список всіх файлів в кореневому каталозі архіву:

```javascript
const fs = require('fs')
fs.readdirSync('/path/to/example.asar')
```

Використовувати модуль в архіві:

```javascript
require('./path/to/example.asar/dir/module.js')
```

Ви також можете відобразити сторінку в архіві `asar` з `BrowserWindow`:

```javascript
const { BrowserWindow } = require('electron')
const win = new BrowserWindow()

win.loadURL('file:///path/to/example.asar/static/index.html')
```

### Web API

На веб-сторінці файли з архіву можуть бути запитані в `файл:` протокол. Як і API вузла, `asar` архіви розглядаються як каталоги.

Наприклад, щоб отримати файл з `$.get`:

```html
<script>
дозволити $ = require('./jquery.min.js')
$.get('file:///path/to/example.asar/file.txt', (data) => {
  console.log(data)
})
</script>
```

### Лікування архіву `asar` до звичайного файлу

Для деяких випадків, таких як перевірка `asar` контрольної суми архіву, нам потрібно прочитати вміст `на asar` архіві як файл. З цієї мети ви можете використовувати вбудований `original-fs` модуль, який надає оригінальний `fs` API без `asar` підтримки:

```javascript
const originalFs = require('original-fs')
originalFs.readFileSync('/path/to/example.asar')
```

Ви також можете встановити `процес. oAsar` для `true` , щоб вимкнути підтримку `asar` у `fs format@@` модуль:

```javascript
const fs = require('fs')
process.noAsar = true
fs.readFileSync('/path/to/example.asar')
```

## Обмеження API вузла

Even though we tried hard to make `asar` archives in the Node API work like directories as much as possible, there are still limitations due to the low-level nature of the Node API.

### Архів лише для читання

Архів не може бути змінений, тому всі API вузла можуть змінювати файли не працювати з `asar` архівами.

### Робоча директорія не може встановлюватися в архіві

Хоча `asar` архіви розглядаються як каталоги, в файловій системі не існує фактично каталогів, так що ви ніколи не можете встановити робочий каталог каталогів в `asar` архіви. Передача їх як `cwd` варіант деяких API також призведе до помилок.

### Додаткове розпакування на деяких API

Більшість `fs` API можуть читати файл або отримати інформацію про файл `asar` архіви без розпакування, але для деяких API-сайтів, які залежать від передачі справжнього шляху до системних дзвінків, Electron вилучить необхідний файл у тимчасовий файл і передасть шлях тимчасового файлу до API, щоб він міг їх освоїти працювати. Це додає трохи більше грошей для цих API.

Додатково розпаковуються API:

* `файл child_process.execFile`
* `uk_process.execFileSync`
* `fs.open`
* `fs.openSync`
* `process.dlopen` - використаний для `вимагає` в власних модулях

### Інформація про фальшивий стан `fs.stat`

The `Stats` object returned by `fs.stat` and its friends on files in `asar` archives is generated by guessing, because those files do not exist on the filesystem. Тому ви не повинні довіряти об'єкту `Статистика` , окрім отримання розміру файлу та перевірки типу файлу.

### Виконання бінарних файлів збоку `asar` Архів

Існують такі бінарні інтерфейси, як `child_process.exec`, `child_process.spawn` та `child_process. xecFile`, але лише `execFile` є підтримуваний виконуваний файл в межах `asar` архів.

Це тому, що `exec` and `призову` прийняти `команду` замість файлу `` як вхідну, і `команда`s виконується під оболонкою. There is no reliable way to determine whether a command uses a file in asar archive, and even if we do, we can not be sure whether we can replace the path in command without side effects.

## Додавання Нерозпакованих Файлів в `asar` Архів

Як вказано вище, деякі API вузла розпакують файл в файлову систему під час виклику. Крім ефективності та антивірусних сканерів може бути викликаний такою поведінкою.

Як обхідний варіант, ви можете залишити розпаковані різні файли, використовуючи параметр `--unpack`. Наприклад, спільні бібліотеки місцевих модулів Node.js не будуть упаковані :

```sh
$ asar pack app app.asar --unpack *.node
```

Після запуску команди ви помітите, що папка з ім'ям `app.asar.unспаковані` була створена разом з файлом `app.asar`. Він містить розпаковані файли і повинен бути відправлений разом з `архівом`.

[asar]: https://github.com/electron/asar
[electron-packager]: https://github.com/electron/electron-packager
[electron-forge]: https://github.com/electron-userland/electron-forge
[electron-builder]: https://github.com/electron-userland/electron-builder
